<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FiddlerCore4</name>
    </assembly>
    <members>
        <member name="M:Fiddler.Winsock.MapLocalPortToProcessId(System.Int32)">
            <summary>
            Map a local port number to the originating process ID
            </summary>
            <param name="iPort">The local port number</param>
            <returns>The originating process ID</returns>
        </member>
        <member name="M:Fiddler.Winsock.FindPIDForConnection(System.Int32,System.UInt32,Fiddler.Winsock.TcpTableType)">
            <summary>
            Calls the GetExtendedTcpTable function to map a port to a process ID.
            This function is (over) optimized for performance.
            </summary>
            <param name="iTargetPort">Client port</param>
            <param name="iAddressType">AF_INET or AF_INET6</param>
            <returns>PID, if found, or 0</returns>
        </member>
        <member name="M:Fiddler.Winsock.FindPIDForPort(System.Int32)">
            <summary>
            Given a local port number, uses GetExtendedTcpTable to find the originating process ID. 
            First checks the IPv4 connections, then looks at IPv6 connections.
            </summary>
            <param name="iTargetPort">Client applications' port</param>
            <returns>ProcessID, or 0 if not found</returns>
        </member>
        <member name="M:Fiddler.Winsock.GetListeningProcess(System.Int32)">
            <summary>
            Returns a string containing the process listening on a given port
            </summary>
        </member>
        <member name="T:Fiddler.Winsock.TcpTableType">
            <summary>
            Enumeration of possible queries that can be issued using GetExtendedTcpTable
            http://msdn2.microsoft.com/en-us/library/aa366386.aspx
            </summary>
        </member>
        <member name="F:Fiddler.Winsock.TcpTableType.OwnerPidListener">
            <summary>
            Processes listening on Ports
            </summary>
        </member>
        <member name="F:Fiddler.Winsock.TcpTableType.OwnerPidConnections">
            <summary>
            Processes with active TCP/IP connections
            </summary>
        </member>
        <member name="T:Fiddler.CertMaker">
            <summary>
            This class is used to find and create certificates for use in HTTPS interception. 
            The default implementation (DefaultCertProvider object) uses the Windows Certificate store, 
            but if a plugin ICertificateProvider is provided, it is used instead.
            </summary>
        </member>
        <member name="F:Fiddler.CertMaker.oCertProvider">
            <summary>
            Enables specification of a delegate certificate provider that generates certificates for HTTPS interception.
            </summary>
        </member>
        <member name="F:Fiddler.CertMaker._lockProvider">
            <summary>
            Lock on this object when TestExistenceOf/Create oCertProvider
            </summary>
        </member>
        <member name="M:Fiddler.CertMaker.EnsureReady">
            <summary>
            Ensures that the Certificate Generator is ready; thread-safe
            </summary>
        </member>
        <member name="M:Fiddler.CertMaker.LoadOverrideCertProvider">
            <summary>
            Load a delegate Certificate Provider
            </summary>
            <returns>The provider, or null</returns>
        </member>
        <member name="M:Fiddler.CertMaker.removeFiddlerGeneratedCerts">
            <summary>
            Removes Fiddler-generated certificates from the Windows certificate store
            </summary>
        </member>
        <member name="M:Fiddler.CertMaker.removeFiddlerGeneratedCerts(System.Boolean)">
            <summary>
            Removes Fiddler-generated certificates from the Windows certificate store
            </summary>
            <param name="bRemoveRoot">Indicates whether Root certificates should also be cleaned up</param>
        </member>
        <member name="M:Fiddler.CertMaker.GetRootCertificate">
            <summary>
            Returns the Root certificate that Fiddler uses to generate per-site certificates used for HTTPS interception.
            </summary>
            <returns>Returns the root certificate, if present, or null if the root certificate does not exist.</returns>
        </member>
        <member name="M:Fiddler.CertMaker.getRootCertBytes">
            <summary>
            Return the raw byte[]s of the root certificate, or null
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.CertMaker.FindCert(System.String)">
            <summary>
            Request a certificate with the specified SubjectCN
            </summary>
            <param name="sHostname">A string of the form: "www.hostname.com"</param>
            <returns>A certificate or /null/ if the certificate could not be found or created</returns>
        </member>
        <member name="M:Fiddler.CertMaker.StoreCert(System.String,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Pre-cache a Certificate in the Certificate Maker that should be returned in subsequent calls to FindCert
            </summary>
            <param name="sHost">The hostname for which this certificate should be returned.</param>
            <param name="oCert">The X509Certificate2 with attached Private Key</param>
            <returns>TRUE if the Certificate Provider succeeded in pre-caching the certificate. FALSE if Provider doesn't support pre-caching. THROWS if supplied Certificate lacks Private Key.</returns>
        </member>
        <member name="M:Fiddler.CertMaker.StoreCert(System.String,System.String,System.String)">
            <summary>
            Pre-cache a Certificate in the Certificate Maker that should be returned in subsequent calls to FindCert
            </summary>
            <param name="sHost">The hostname for which this certificate should be returned.</param>
            <param name="sPFXFilename">The filename of the PFX file containing the certificate and private key</param>
            <param name="sPFXPassword">The password for the PFX file</param>
            <notes>Throws if the Certificate Provider failed to pre-cache the certificate</notes>
        </member>
        <member name="M:Fiddler.CertMaker.rootCertExists">
            <summary>
            Determine if the self-signed root certificate exists
            </summary>
            <returns>True if the Root certificate returned from <see cref="M:Fiddler.CertMaker.GetRootCertificate">GetRootCertificate</see> is non-null, False otherwise.</returns>
        </member>
        <member name="M:Fiddler.CertMaker.rootCertIsTrusted">
            <summary>
            Is Fiddler's root certificate in the Root store?
            </summary>
            <returns>TRUE if so</returns>
        </member>
        <member name="M:Fiddler.CertMaker.rootCertIsMachineTrusted">
            <summary>
            Is Fiddler's root certificate in the Machine Root store?
            </summary>
            <returns>TRUE if so</returns>
        </member>
        <member name="M:Fiddler.CertMaker.createRootCert">
            <summary>
            Create a self-signed root certificate to use as the trust anchor for HTTPS interception certificate chains
            </summary>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:Fiddler.CertMaker.trustRootCert">
            <summary>
            Finds the Fiddler root certificate and prompts the user to add it to the TRUSTED store.
            Note: The system certificate store is used by most applications (IE, Chrome, etc) but not
            all; for instance, Firefox uses its own certificate store.
            </summary>
            <returns>True if successful</returns>
        </member>
        <member name="M:Fiddler.CertMaker.DoDispose">
            <summary>
            Dispose of the Certificate Provider, if any.
            </summary>
        </member>
        <member name="T:Fiddler.ClientChatter">
            <summary>
            The ClientChatter object, exposed as the oRequest object on the Session object, represents a single web request.
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.s_cbClientReadBuffer">
            <summary>
            Size of buffer passed to pipe.Receive when reading from the client. 
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.stateRead">
            <summary>
            Tracks the progress of reading the request from the client. Because of the multi-threaded nature 
            of some users of this field, most will make a local copy before accessing its members.
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.pipeClient">
            <summary>
            The ClientPipe object which is connected to the client, or null.
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.m_headers">
            <summary>
            Parsed Headers
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.m_session">
            <summary>
            The Session object which owns this ClientChatter
            </summary>
        </member>
        <member name="M:Fiddler.ClientChatter.#ctor(Fiddler.Session,System.String)">
            <summary>
            Create a ClientChatter object initialized with a set of HTTP headers
            Called primarily when loading session data from a file.
            </summary>
            <param name="oSession">The Session object which will own this request</param>
            <param name="sData">The string containing the request data</param>
        </member>
        <member name="M:Fiddler.ClientChatter.ReadRequestBodyFromFile(System.String)">
            <summary>
            Loads a HTTP request body from a file rather than a memory stream.
            </summary>
            <param name="sFilename">The file to load</param>
            <returns>TRUE if the file existed. THROWS on most errors other than File-Not-Found</returns>
        </member>
        <member name="M:Fiddler.ClientChatter._calculateExpectedEntityTransferSize">
            <summary>
            Based on this session's data, determine the expected Transfer-Size of the request body. See RFC2616 Section 4.4 Message Length.
            Note, there's currently no support for "multipart/byteranges" requests anywhere in Fiddler.
            </summary>
            <returns>Expected Transfer-Size of the body, in bytes.</returns>
        </member>
        <member name="M:Fiddler.ClientChatter._freeRequestData">
            <summary>
            Free Request data. Called by TakeEntity or by ReadRequest method on request failure
            </summary>
        </member>
        <member name="M:Fiddler.ClientChatter.TakeEntity">
            <summary>
            Extract byte array representing the entity, put any excess bytes back in the pipe, free the RequestReadState, and 
            return the entity.
            </summary>
            <returns>Byte array containing the entity body</returns>
        </member>
        <member name="M:Fiddler.ClientChatter.FailSession(System.Int32,System.String,System.String)">
            <summary>
            Send a HTTP/XXX Error Message to the Client, calling FiddlerApplication.BeforeReturningError and DoReturningError in FiddlerScript.
            Note: This method does not poison the Server pipe, so if poisoning is desired, it's the caller's responsibility to do that.
            Note: Because this method uses Connection: close on the returned response, it has the effect of poisoning the client pipe
            </summary>
            <param name="iError">Response code</param>
            <param name="sErrorStatusText">Response status text</param>
            <param name="sErrorBody">Body of the HTTP Response</param>
        </member>
        <member name="M:Fiddler.ClientChatter.BuildAndReturnResponse(System.Int32,System.String,System.String,System.Action{Fiddler.Session})">
            <summary>
            Return a HTTP response and signal that the client should close the connection
            </summary>
            <param name="delLastChance">A Delegate that fires to give one final chance to modify the Session before
            calling the DoBeforeReturningError and returning the response</param>
        </member>
        <member name="M:Fiddler.ClientChatter._ParseRequestForHeaders">
            <summary>
            Parse the headers from the requestData buffer.  
            Precondition: Call AFTER having set the correct iEntityBodyOffset.
            
            Note: This code used to be a lot simpler before, when it used strings instead of byte[]s. Sadly,
            we've gotta use byte[]s to ensure nothing in the URI gets lost.
            </summary>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:Fiddler.ClientChatter._isRequestComplete">
            <summary>
            This function decides if the request string represents a complete HTTP request
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ClientChatter.ReadRequest">
            <summary>
            Read a (usually complete) request from pipeClient. If RequestStreamed flag is set, only the headers have been read.
            </summary>
            <returns>TRUE, if a request could be read. FALSE, otherwise.</returns>
        </member>
        <member name="M:Fiddler.ClientChatter._ValidateHostDuringReadRequest">
            <summary>
            Verifies that the Hostname specified in the request line is compatible with the HOST header
            </summary>
        </member>
        <member name="P:Fiddler.ClientChatter._PeekUploadProgress">
            <summary>
            Count of body bytes read from the client. If no body bytes have yet been read, returns count of header bytes.
            </summary>
        </member>
        <member name="P:Fiddler.ClientChatter.headers">
            <summary>
            HTTP Headers sent in the client request, or null.
            </summary>
        </member>
        <member name="P:Fiddler.ClientChatter.bClientSocketReused">
            <summary>
            Was this request received from a reused client connection? Looks at SessionFlags.ClientPipeReused flag on owning Session.
            </summary>
        </member>
        <member name="P:Fiddler.ClientChatter.host">
            <summary>
            Note: This returns the request's HOST header, which may include a trailing port #.
            If the Host is an IPv6 literal, it will be enclosed in brackets '[' and ']'
            </summary>
        </member>
        <member name="P:Fiddler.ClientChatter.BufferRequest">
            <summary>
            Controls whether the request body is streamed to the server as it is read from the client.
            </summary>
        </member>
        <member name="P:Fiddler.ClientChatter.Item(System.String)">
            <summary>
            Simple indexer into the Request Headers object
            </summary>
        </member>
        <member name="T:Fiddler.ClientChatter.RequestReaderState">
            <summary>
            Discardable State of Read Operation
            
            While it is reading a request from the client, the ClientChatter class uses a RequestReaderState object to track
            the state of the read. This state is discarded when the request has been completely read.
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.m_sHostFromURI">
            <summary>
            The Host pulled from the URI
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.m_requestData">
            <summary>
            Buffer holds this request's data as it is read from the pipe.
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.iEntityBodyOffset">
            <summary>
            Offset to first byte of body in m_requestData
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.m_lngLastChunkInfoOffset">
            <summary>
            Optimization: Offset of most recent transfer-encoded chunk
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.iBodySeekProgress">
            <summary>
            Optimization: tracks how far we've previously looked when determining iEntityBodyOffset
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.bIsChunkedBody">
            <summary>
            Did the request specify Transfer-Encoding: chunked
            </summary>
        </member>
        <member name="F:Fiddler.ClientChatter.RequestReaderState.iContentLength">
            <summary>
            The integer value of the Content-Length header, if any
            </summary>
        </member>
        <member name="M:Fiddler.ClientChatter.RequestReaderState.GetBodyBytesRead">
            <summary>
            Count of body bytes read from the client. If no body bytes have yet been read, returns count of header bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ClientChatter.RequestReaderState._areHeadersAvailable(Fiddler.Session)">
             <summary>
             Scans requestData stream for the \r\n\r\n (or variants) sequence
             which indicates that the header block is complete.
            
             SIDE EFFECTS:
            		iBodySeekProgress is updated and maintained across calls to this function
            		iEntityBodyOffset is updated if the end of headers is found
             </summary>
             <returns>True, if requestData contains a full set of headers</returns>
        </member>
        <member name="T:Fiddler.CONFIG">
            <summary>
            The CONFIG object is Fiddler's legacy settings object, introduced before the advent of the Preferences system.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG._Prefs">
            <summary>
            Underlying Preferences container whose IFiddlerPreferences interface is 
            exposed by the FiddlerApplication.Prefs property.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG._cb_STREAM_LARGE_FILES">
            <summary>
            Response files larger than this (2^28 = ~262mb) will NOT be loaded into memory when using LoadResponseFromFile
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bQuietMode">
            <summary>
            Backing field for the QuietMode property. Controls whether notifications are displayed in a MessageBox.
            NB: KEEP THIS FIELD DECLARED AT THE TOP OF THE CLASS. We initialize some fields using methods that can check this field.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sLVColInfo">
            <summary>
            Cached layout info for columns.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bIsViewOnly">
            <summary>
            True if this is a "Viewer" instance of Fiddler that will not persist its settings. Exposed as FiddlerApplication.IsViewerMode
            </summary>
            <remarks>
            TODO: ARCH: This setting shouldn't exist in FiddlerCore, but it's used in a dozen places</remarks>
        </member>
        <member name="F:Fiddler.CONFIG.bUseXceedDecompressForGZIP">
            <summary>
            TODO: Why is this defaulted to FALSE? Has been since 2009, probably due to some bug. Should keep better records. (Sigh).
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bMapSocketToProcess">
            <summary>
            Boolean controls whether Fiddler should map inbound connections to their original process using IPHLPAPI
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bMITM_HTTPS">
            <summary>
            Boolean controls whether Fiddler should attempt to decrypt HTTPS Traffic
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bUseSNIForCN">
            <summary>
            Boolean controls whether Fiddler will attempt to use the Server Name Indicator TLS extension to generate the SubjectCN for certificates
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bStreamAudioVideo">
            <summary>
            Should Audio/Video types automatically stream by default?
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sFiddlerListenHostPort">
            <summary>
            Returns 127.0.0.1:{ListenPort} or fiddler.network.proxy.RegistrationHostName:{ListenPort}
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bUseAESForSAZ">
            <summary>
            Use 128bit AES Encryption when password-protecting .SAZ files. Note that, while this 
            encryption is much stronger than the default encryption algorithm, it is significantly
            slower to save and load these files, and the Windows Explorer ZIP utility cannot open them.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.oAcceptedClientHTTPSProtocols">
            <summary>
            SSL/TLS Protocols we allow the client to choose from (when we call AuthenticateAsServer)
            We allow all protocols by default (Ssl2,Ssl3,Tls1) and also 'Bitwise OR' in the constants for TLS1.1 and TLS1.2 in case we happen to be running on .NET4.5.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.oAcceptedServerHTTPSProtocols">
            <summary>
            SSL/TLS Protocols we request the server use (when we call AuthenticateAsClient). By default, SSL3 and TLS1 are accepted; we exclude SSL2 so that TLS Extensions may be sent.
            We do NOT enable TLS1.1 or TLS1.2 by default because many servers will fail if you offer them and unlike browsers, .NET has no fallback code.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bMimicClientHTTPSProtocols">
            <summary>
            When True, Fiddler will offer the latest TLS protocol version offered by the client in its request
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.FiddlerVersionInfo">
            <summary>
            Version information for the Fiddler/FiddlerCore assembly
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bForwardToGateway">
            <summary>
            Will send traffic to an upstream proxy?
            OBSOLETE -- DO NOT USE. see <see cref="P:Fiddler.CONFIG.UpstreamGateway"/> instead.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.oHeaderEncoding">
            <summary>
            The encoding with which HTTP Headers should be parsed. Defaults to UTF8, but may be overridden by specifying a REG_SZ containing the encoding name in the registry key \Fiddler2\HeaderEncoding
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bReuseServerSockets">
            <summary>
            Controls whether Fiddler will reuse server connections for multiple sessions
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bReuseClientSockets">
            <summary>
            Controls whether Fiddler will reuse client connections for multiple sessions
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bCaptureCONNECT">
            <summary>
            Controls whether Fiddler should register as the HTTPS proxy
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bCaptureFTP">
            <summary>
            Controls whether Fiddler should register as the FTP proxy
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bUseEventLogForExceptions">
            <summary>
            Controls whether Fiddler will try to write exceptions to the System Event log. Note: Usually fails due to ACLs on the Event Log.
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bAutoProxyLogon">
            <summary>
            Controls whether Fiddler will attempt to log on to the upstream proxy server to download the proxy configuration script
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bEnableIPv6">
            <summary>
            Controls whether Fiddler will attempt to connect to IPv6 addresses
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sHookConnectionNamed">
            <summary>
            Name of connection to which Fiddler should autoattach if MonitorAllConnections is not set
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sGatewayUsername">
            <summary>
            The username to send to the upstream gateway if the Version Checking webservice request requires authentication
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sGatewayPassword">
            <summary>
            The password to send to the upstream gateway if the Version Checking webservice request requires authentication
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bUsingPortOverride">
            <summary>
            Set this flag if m_ListenPort is a "temporary" port (E.g. specified on command-line) and it shouldn't be overridden in the registry
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.bDebugCertificateGeneration">
            <summary>
            Controls whether Certificate-Generation output will be spewed to the Fiddler Log
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sAlternateHostname">
            <summary>
            Alternative hostname which Fiddler should recognize as an alias for the local machine. The
            default value of ? will never be usable, as it's the QueryString delimiter
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sMachineName">
            <summary>
            (Lowercase) Machine Name
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.sMachineDomain">
            <summary>
            (Lowercase) Machine Domain Name
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.oHLSkipDecryption">
            <summary>
            List of hostnames for which HTTPS decryption (if enabled) should be skipped
            </summary>
        </member>
        <member name="F:Fiddler.CONFIG.fNeedToMaximizeOnload">
            <summary>
            True if Fiddler should be maximized on restart
            </summary>
        </member>
        <member name="M:Fiddler.CONFIG.GetUrl(System.String)">
            <summary>
            Return a Special URL.
            </summary>
            <param name="sWhatUrl">String constant describing the URL to return. CASE-SENSITIVE!</param>
            <returns>Returns target URL</returns>
        </member>
        <member name="M:Fiddler.CONFIG.GetRegPath(System.String)">
            <summary>
            Get a registry path for a named constant
            </summary>
            <param name="sWhatPath">The path to retrieve [Root, UI, Dynamic, Prefs]</param>
            <returns>The registry path</returns>
        </member>
        <member name="M:Fiddler.CONFIG.GetPath(System.String)">
            <summary>
            Return an app path (ending in Path.DirectorySeparatorChar) or a filename
            </summary>
            <param name="sWhatPath">CASE-SENSITIVE</param>
            <returns>The specified filesystem path</returns>
        </member>
        <member name="M:Fiddler.CONFIG.EnsureFoldersExist">
            <summary>
            Ensure that the per-user folders used by Fiddler are present.
            </summary>
        </member>
        <member name="M:Fiddler.CONFIG._LoadPreferences">
            <summary>
            Loads Preferences from the Registry and fills appropriate fields
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.RawPrefs">
            <summary>
            Generally, callers should use FiddlerApplication.Prefs, but RawPrefs allows use of the PreferenceBag members that
            are not a part of IFiddlerPreferences
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.DecryptWhichProcesses">
            <summary>
            Control which processes have HTTPS traffic decryption enabled
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.UpstreamGateway">
            <summary>
            What mechanism, if any, should Fiddler use to find the upstream proxy/gateway?
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.iReverseProxyForPort">
            <summary>
            Port to which Fiddler should forward inbound requests when configured to run as a Reverse Proxy
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.sHostsThatBypassFiddler">
            <summary>
            On attach, will configure WinINET to bypass Fiddler for these hosts.
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.ForceExclusivePort">
            <summary>
            Boolean indicating whether Fiddler will open the listening port exclusively
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.IgnoreServerCertErrors">
            <summary>
            Controls whether server certificate errors are ignored when decrypting HTTPS traffic.
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.QuietMode">
            <summary>
            Controls whether notification dialogs and prompts should be shown.
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.ListenPort">
            <summary>
            The port upon which Fiddler is configured to listen.
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.JSEditor">
            <summary>
            Returns the path and filename of the editor used to edit the Rules script file.
            </summary>
        </member>
        <member name="P:Fiddler.CONFIG.bAllowRemoteConnections">
            <summary>
            Returns true if Fiddler should permit remote connections. Requires restart.
            </summary>
        </member>
        <member name="T:Fiddler.RetryMode">
            <summary>
            When may requests be resent on a new connection?
            </summary>
        </member>
        <member name="F:Fiddler.RetryMode.Always">
            <summary>
            The request may always be retried.
            </summary>
        </member>
        <member name="F:Fiddler.RetryMode.Never">
            <summary>
            The request may never be retried
            </summary>
        </member>
        <member name="F:Fiddler.RetryMode.IdempotentOnly">
            <summary>
            The request may only be resent if the HTTP Method is idempotent.
            This SHOULD be the default per HTTP spec, but this appears to break tons of servers.
            </summary>
        </member>
        <member name="T:Fiddler.GatewayType">
            <summary>
            Type of Upstream Gateway
            </summary>
        </member>
        <member name="F:Fiddler.GatewayType.None">
            <summary>
            Traffic should be sent directly to the server
            </summary>
        </member>
        <member name="F:Fiddler.GatewayType.Manual">
            <summary>
            Traffic should be sent to a manually-specified proxy
            </summary>
        </member>
        <member name="F:Fiddler.GatewayType.System">
            <summary>
            Traffic should be sent to the System-configured proxy
            </summary>
        </member>
        <member name="F:Fiddler.GatewayType.WPAD">
            <summary>
            Proxy should be automatically detected
            </summary>
        </member>
        <member name="T:Fiddler.ProcessFilterCategories">
            <summary>
            A simple Process Type enumeration used by various filtering features
            </summary>
        </member>
        <member name="F:Fiddler.ProcessFilterCategories.All">
            <summary>
            Include all Processes
            </summary>
        </member>
        <member name="F:Fiddler.ProcessFilterCategories.Browsers">
            <summary>
            Processes which appear to be Web Browsers
            </summary>
        </member>
        <member name="F:Fiddler.ProcessFilterCategories.NonBrowsers">
            <summary>
            Processes which appear to NOT be Web Browsers
            </summary>
        </member>
        <member name="F:Fiddler.ProcessFilterCategories.HideAll">
            <summary>
            Include only traffic where Process ID isn't known (e.g. remote clients)
            </summary>
        </member>
        <member name="T:Fiddler.ITunnel">
            <summary>
            Interface for the WebSocket and CONNECT Tunnel classes
            </summary>
        </member>
        <member name="T:Fiddler.CONNECTTunnel">
            <summary>
            The CONNECTTunnel class represents a "blind tunnel" through which a CONNECT request is serviced to shuffle bytes between a client and the server.
            </summary>
            <remarks>
            See pg 206 in HTTP: The Complete Reference for details on how Tunnels work.
            When HTTPS Decryption is disabled, Fiddler accepts a CONNECT request from the client. Then, we open a connection to the remote server. 
            We shuttle bytes back and forth between the client and the server in this tunnel, keeping Fiddler itself out of the loop
            (no tampering, etc). 
            </remarks>
        </member>
        <member name="F:Fiddler.CONNECTTunnel._lngEgressByteCount">
            <summary>
            Number of bytes received from the client
            </summary>
        </member>
        <member name="F:Fiddler.CONNECTTunnel._lngIngressByteCount">
            <summary>
            Number of bytes received from the server
            </summary>
        </member>
        <member name="F:Fiddler.CONNECTTunnel.bIsBlind">
            <summary>
            TRUE if this is a Blind tunnel, FALSE if decrypting
            </summary>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.CreateTunnel(Fiddler.Session)">
            <summary>
            This "Factory" method creates a new HTTPS Tunnel and executes it on a background (non-pooled) thread.
            </summary>
            <param name="oSession">The Session containing the HTTP CONNECT request</param>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.#ctor(Fiddler.Session,Fiddler.ClientPipe,Fiddler.ServerPipe)">
            <summary>
            Creates a HTTPS tunnel. External callers instead use the CreateTunnel static method.
            </summary>
            <param name="oSess">The session for which this tunnel was initially created.</param>
            <param name="oFrom">Client Pipe</param>
            <param name="oTo">Server Pipe</param>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.WaitForCompletion">
            <summary>
            This function keeps the thread alive until it is signaled that the traffic is complete
            </summary>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.RunTunnel">
            <summary>
            Executes the HTTPS tunnel inside an All-it-can-eat exception handler.
            Call from a background thread.
            </summary>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.CloseTunnel">
            <summary>
            Close the HTTPS tunnel and signal the event to let the service thread die.
            WARNING: This MUST not be allowed to throw any exceptions, because it will do so on threads that don't catch them, and this will kill the application.
            </summary>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.OnClientReceive(System.IAsyncResult)">
            <summary>
            	Called when we have received data from the local client.
            	Incoming data will immediately be forwarded to the remote host.
            </summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.OnClientSent(System.IAsyncResult)">
            <summary>Called when we have sent data to the local client.<br>When all the data has been sent, we will start receiving again from the remote host.</br></summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.OnRemoteSent(System.IAsyncResult)">
            <summary>Called when we have sent data to the remote host.<br>When all the data has been sent, we will start receiving again from the local client.</br></summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.CONNECTTunnel.OnRemoteReceive(System.IAsyncResult)">
            <summary>Called when we have received data from the remote host.<br>Incoming data will immediately be forwarded to the local client.</br></summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="P:Fiddler.CONNECTTunnel.IngressByteCount">
            <summary>
            Returns number of bytes sent from the Server to the Client
            </summary>
        </member>
        <member name="P:Fiddler.CONNECTTunnel.EgressByteCount">
            <summary>
            Returns number of bytes sent from the Client to the Server
            </summary>
        </member>
        <member name="T:Fiddler.ICertificateProvider2">
            <summary>
            To override default certificate handling, your class should implement this interface in an assembly 
            referenced by the fiddler.certmaker.assembly preference; by default, "certmaker.dll" in the application
            folder is loaded
            </summary>
        </member>
        <member name="T:Fiddler.ICertificateProvider">
            <summary>
            Implement ICertificateProvider2 instead
            </summary>
        </member>
        <member name="M:Fiddler.ICertificateProvider.GetCertificateForHost(System.String)">
            <summary>
            Return a certificate to secure this traffic. Generally, it's expected that this method WILL create a new certificate if needed. 
            </summary>
            <param name="sHostname">Hostname (e.g. "www.example.com")</param>
            <returns>An X509Certificate, or null on error</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider.GetRootCertificate">
            <summary>
            Return the root certificate to which Host Certificates are chained. Generally, it's expected that this method will NOT create a root certificate.
            </summary>
            <returns>An X509Certificate, or null on error</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider.CreateRootCertificate">
            <summary>
            When this method is called, your extension should create a Root certificate.
            </summary>
            <returns>TRUE if the operation was successful</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider.TrustRootCertificate">
            <summary>
            When this method is called, your extension should copy the your Root certificate into
            the user's (or machines's) Root certificate store.
            </summary>
            <returns>TRUE if the operation was successful</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider.ClearCertificateCache">
            <summary>
            When this method is called, your extension should discard all certificates and 
            clear any certificates that have been added to the user's certificate store.
            </summary>
            <returns>TRUE, if all certificates were removed; FALSE if any certificates were preserved</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider.rootCertIsTrusted(System.Boolean@,System.Boolean@)">
            <summary>
            When this method is called, your extension should check to see if the User or Machine Root 
            certificate store contains your Root certificate.
            </summary>
            <param name="bUserTrusted">Set to TRUE if StoreLocation.CurrentUser StoreName.Root has the certificate</param>
            <param name="bMachineTrusted">Set to TRUE if StoreLocation.LocalMachine StoreName.Root has the certificate</param>
            <returns>TRUE if either bUserTrusted or bMachineTrusted</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider2.ClearCertificateCache(System.Boolean)">
            <summary>
            When this method is called, your extension should discard all certificates and 
            clear any certificates that have been added to the user's certificate store
            </summary>
            <param name="bClearRoot">TRUE if the root certificate should also be cleared</param>
            <returns>TRUE, if all certificates were removed; FALSE if any certificates were preserved</returns>
        </member>
        <member name="M:Fiddler.ICertificateProvider3.CacheCertificateForHost(System.String,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Call this function to cache a certificate in the Certificate Provider
            </summary>
            <param name="sHost">The hostname to match</param>
            <param name="oCert">The certificate that the Provider should later provide when GetCertificateForHost is called</param>
            <returns>True if the request was successful</returns>
        </member>
        <member name="M:Fiddler.ICertificateProviderInfo.GetConfigurationString">
            <summary>
            Return a string describing the current configuration of the Certificate Provider. For instance, list
            the configured key size, hash algorithms, etc.
            </summary>
        </member>
        <member name="M:Fiddler.ICertificateProviderInfo.ShowConfigurationUI(System.IntPtr)">
            <summary>
            Show a configuration dialog that allows user to control options related to your Certificate Provider,
            for instance, the configured key size, hash algorithm, etc.
            </summary>
            <param name="hwndOwner">Owning Window Handle</param>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider.CertCreator">
            <summary>
            The underlying Certificate Generator (MakeCert or CertEnroll)
            </summary>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider.certServerCache">
            <summary>
            Cache of previously-generated EE certificates. Thread safety managed by _oRWLock
            </summary>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider.certRoot">
            <summary>
            Cache of previously-generated Root certificate
            </summary>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider.UseWildcards">
            <summary>
            Should Fiddler automatically generate wildcard certificates?
            </summary>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider._oRWLock">
            <summary>
            Reader/Writer lock gates access to the certificate cache and generation functions.
            </summary>
            <remarks>We must set the SupportsRecursion flag because there are cases where the thread holds the lock in Write mode and then enters Read mode in a nested call.</remarks>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.FindCertsBySubject(System.Security.Cryptography.X509Certificates.StoreName,System.Security.Cryptography.X509Certificates.StoreLocation,System.String)">
            <summary>
            Find certificates that have the specified full subject.
            </summary>
            <param name="storeName">The store to search</param>
            <param name="sFullSubject">FindBySubject{Distinguished}Name requires a complete match of the SUBJECT, including CN, O, and OU</param>
            <returns>Matching certificates</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.FindCertsByIssuer(System.Security.Cryptography.X509Certificates.StoreName,System.String)">
            <summary>
            Find all certificates (in the CurrentUser Personal store) that have the specified issuer.
            </summary>
            <param name="storeName">The store to search</param>
            <param name="sFullIssuerSubject">FindByIssuer{Distinguished}Name requires a complete match of the SUBJECT, including CN, O, and OU</param>
            <returns>Matching certificates</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.ClearCertificateCache(System.Boolean)">
            <summary>
            Interface method: Clear the in-memory caches and Windows certificate stores
            </summary>
            <param name="bRemoveRoot">TRUE to clear the Root Certificate from the cache and Windows stores</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.ClearCertificateCache">
            <summary>
            Interface method: Clear the in-memory caches and Windows certificate stores
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.CreateRootCertificate">
            <summary>
            Use MakeCert to generate a unique self-signed certificate
            </summary>
            <returns>TRUE if the Root certificate was generated successfully</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.GetRootCertificate">
            <summary>
            Get the root certificate from cache or storage, only IF IT ALREADY EXISTS.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.GetCertificateForHost(System.String)">
            <summary>
            Returns an Interception certificate for the specified hostname
            </summary>
            <param name="sHostname">Hostname for the target certificate</param>
            <remarks>This method uses a Reader lock when checking the cache and a Writer lock when updating the cache.</remarks>
            <returns>An Interception Certificate, or NULL</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.LoadOrCreateCertificate(System.String,System.Boolean@)">
            <summary>
            Find a certificate from the certificate store, creating a new certificate if it was not found.
            </summary>
            <param name="sHostname">A SubjectCN hostname, of the form www.example.com</param>
            <param name="bAttemptedCreation">TRUE if the cert wasn't found in the Windows Certificate store and this function attempted to create it.</param>
            <remarks>No locks are acquired by this method itself.</remarks>
            <returns>A certificate or /null/</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.LoadCertificateFromWindowsStore(System.String)">
            <summary>
            Find (but do not create!) a certificate from the CurrentUser certificate store, if present.
            </summary>
            <remarks>No locks are acquired by this method itself.</remarks>
            <returns>A certificate or /null/</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.CacheCertificateForHost(System.String,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Updates the Server Certificate cache under the Writer lock
            </summary>
            <param name="sHost">The target hostname</param>
            <param name="oCert">The certificate to cache</param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.CreateCert(System.String,System.Boolean)">
            <summary>
            Creates a certificate for ServerAuth. If isRoot is set, designates that this is a self-signed root.
            </summary>
            <remarks>Uses a reader lock when checking for the Root certificate. Uses a Writer lock when creating a certificate.</remarks>
            <param name="sHostname">A string of the form: "www.hostname.com"</param>
            <param name="isRoot">A boolean indicating if this is a request to create the root certificate</param>
            <returns>Newly-created certificate, or Null</returns>
        </member>
        <member name="T:Fiddler.DefaultCertificateProvider.CertEnrollEngine">
            <summary>
            CertEnroll is an ActiveX Control available on Windows Vista and later that allows programmatic generation of X509 certificates.
            We can use it as an alternative to MakeCert.exe; it offers better behavior (e.g. setting AKID) and doesn't require redistributing makecert.exe
            </summary>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.CertEnrollEngine.GetEngine(Fiddler.ICertificateProvider3)">
            <summary>
            Factory method. Returns null if this engine cannot be created
            </summary>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.CertEnrollEngine.InternalCreateCert(System.String,System.Boolean,System.Boolean)">
            <summary>
            Invoke CertEnroll
            </summary>
            <param name="sSubjectCN">Target CN</param>
            <param name="isRoot">TRUE if the certificate is a root cert</param>
            <param name="switchToMTAIfNeeded">TRUE if we should validate that we're running in a MTA thread and switch if not</param>
            <returns>A Cert</returns>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.MakeCertEngine.GetEngine">
            <summary>
            Factory method. Returns null if this engine cannot be created
            </summary>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider.MakeCertEngine._sMakeCertLocation">
            <summary>
            File path pointing to the location of MakeCert.exe
            </summary>
        </member>
        <member name="F:Fiddler.DefaultCertificateProvider.MakeCertEngine._sDefaultHash">
            <summary>
            Hash to use when signing certificates.
            Note: sha1 is required on XP (even w/SP3, using sha256 throws 0x80090008).
            </summary>
        </member>
        <member name="M:Fiddler.DefaultCertificateProvider.MakeCertEngine.#ctor">
            <summary>
            Constructor: Simply cache the path to MakeCert
            </summary>
        </member>
        <member name="F:Fiddler.DNSResolver.dictAddresses">
            <summary>
            Cache of Hostname->Address mappings
            </summary>
        </member>
        <member name="F:Fiddler.DNSResolver.MSEC_DNS_CACHE_LIFETIME">
            <summary>
            Number of milliseconds that a DNS cache entry may be reused without validation.
            </summary>
        </member>
        <member name="F:Fiddler.DNSResolver.COUNT_MAX_A_RECORDS">
            <summary>
            Maximum number of A/AAAA records to cache for DNS entries.
            Beware: Changing this number changes how many IP-failovers Fiddler will perform if fiddler.network.dns.fallback is set,
            and increasing the number will consume more memory in the cache.
            </summary>
        </member>
        <member name="M:Fiddler.DNSResolver.ClearCache">
            <summary>
            Clear the DNS Cache. Called by the NetworkChange event handler in the oProxy object
            </summary>
        </member>
        <member name="M:Fiddler.DNSResolver.ScavengeCache">
            <summary>
            Remove all expired DNSCache entries; called by the Janitor
            </summary>
        </member>
        <member name="M:Fiddler.DNSResolver.InspectCache">
            <summary>
            Show the contents of the DNS Resolver cache
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.DNSResolver.GetIPAddress(System.String,System.Boolean)">
            <summary>
            Gets first available IP Address from DNS. Throws if address not found!
            </summary>
            <param name="sRemoteHost">String containing the host</param>
            <param name="bCheckCache">True to use Fiddler's DNS cache.</param>
            <returns>IPAddress of target, if found.</returns>
        </member>
        <member name="M:Fiddler.DNSResolver.GetIPAddressList(System.String,System.Boolean,Fiddler.SessionTimers)">
            <summary>
            Gets IP Addresses for host from DNS. Throws if address not found!
            </summary>
            <param name="sRemoteHost">String containing the host</param>
            <param name="bCheckCache">True to use Fiddler's DNS cache.</param>
            <param name="oTimers">The Timers object to which the DNS lookup time should be stored, or null</param>
            <returns>List of IPAddresses of target, if any found.</returns>
        </member>
        <member name="M:Fiddler.DNSResolver.trimAddressList(System.Net.IPAddress[])">
            <summary>
            Trim an address list, removing the duplicate entries, any IPv6-entries if IPv6 is disabled, 
            and entries beyond the COUNT_MAX_A_RECORDS limit.
            </summary>
            <param name="arrResult">The list to filter</param>
            <returns>A filtered address list</returns>
        </member>
        <member name="T:Fiddler.DNSResolver.DNSCacheEntry">
            <summary>
            A DNSCacheEntry holds a cached resolution from the DNS
            </summary>
        </member>
        <member name="F:Fiddler.DNSResolver.DNSCacheEntry.iLastLookup">
            <summary>
            TickCount of this record's creation
            </summary>
        </member>
        <member name="F:Fiddler.DNSResolver.DNSCacheEntry.arrAddressList">
            <summary>
            IPAddresses for this hostname
            </summary>
        </member>
        <member name="M:Fiddler.DNSResolver.DNSCacheEntry.#ctor(System.Net.IPAddress[])">
            <summary>
            Construct a new cache entry
            </summary>
            <param name="arrIPs">The address information to add to the cache</param>
        </member>
        <member name="T:Fiddler.RequiredVersionAttribute">
            <summary>
            Attribute used to specify the minimum version of Fiddler compatible with this extension assembly. 
            </summary>
        </member>
        <member name="M:Fiddler.RequiredVersionAttribute.#ctor(System.String)">
            <summary>
            Attribute used to specify the minimum version of Fiddler compatible with this extension assembly.
            </summary>
            <param name="sVersion">The minimal version string (e.g. "2.2.8.8")</param>
        </member>
        <member name="P:Fiddler.RequiredVersionAttribute.RequiredVersion">
            <summary>
            Getter for the required version string
            </summary>
        </member>
        <member name="T:Fiddler.ProfferFormatAttribute">
            <summary>
            Attribute allowing developer to specify that a class supports the specified Import/Export Format
            </summary>
        </member>
        <member name="M:Fiddler.ProfferFormatAttribute.#ctor(System.String,System.String)">
            <summary>
            Attribute allowing developer to specify that a class supports the specified Import/Export Format
            </summary>
            <param name="sFormatName">Shortname of the Format (e.g. WebText XML)</param>
            <param name="sDescription">Description of the format</param>
        </member>
        <member name="M:Fiddler.ProfferFormatAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Attribute allowing developer to specify that a class supports the specified Import/Export Format
            </summary>
            <param name="sFormatName">Shortname of the Format (e.g. WebText XML)</param>
            <param name="sDescription">Description of the format</param>
            <param name="s">Semi-colon delimited file extensions (e.g. ".har;.harx")</param>
        </member>
        <member name="P:Fiddler.ProfferFormatAttribute.FormatName">
            <summary>
            Returns the Shortname for this format
            </summary>
        </member>
        <member name="P:Fiddler.ProfferFormatAttribute.FormatDescription">
            <summary>
            Returns the Description of this format
            </summary>
        </member>
        <member name="T:Fiddler.TranscoderTuple">
            <summary>
            This tuple maps a display descriptive string to a Import/Export type.
            (The parent dictionary contains the shortname string)
            </summary>
        </member>
        <member name="F:Fiddler.TranscoderTuple.sFormatDescription">
            <summary>
            Textual description of the Format
            </summary>
        </member>
        <member name="F:Fiddler.TranscoderTuple.typeFormatter">
            <summary>
            Class implementing the format
            </summary>
        </member>
        <member name="F:Fiddler.TranscoderTuple._pfa">
            <summary>
            All metadata about the provider
            </summary>
        </member>
        <member name="M:Fiddler.TranscoderTuple.#ctor(Fiddler.ProfferFormatAttribute,System.Type)">
            <summary>
            Create a new Transcoder Tuple
            </summary>
            <param name="sDescription">Format description</param>
            <param name="oFormatter">Type implementing this format</param>
        </member>
        <member name="T:Fiddler.ISessionImporter">
            <summary>
            ISessionImport allows loading of Session data
            </summary>
        </member>
        <member name="M:Fiddler.ISessionImporter.ImportSessions(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.EventHandler{Fiddler.ProgressCallbackEventArgs})">
            <summary>
            Import Sessions from a data source
            </summary>
            <param name="sImportFormat">Shortname of the format</param>
            <param name="dictOptions">Dictionary of options that the Importer class may use</param>
            <param name="evtProgressNotifications">Callback event on which progress is reported or the host may cancel</param>
            <returns>Array of Session objects imported from source</returns>
        </member>
        <member name="T:Fiddler.ISessionExporter">
            <summary>
            ISessionExport allows saving of Session data
            </summary>
        </member>
        <member name="M:Fiddler.ISessionExporter.ExportSessions(System.String,Fiddler.Session[],System.Collections.Generic.Dictionary{System.String,System.Object},System.EventHandler{Fiddler.ProgressCallbackEventArgs})">
            <summary>
            Export Sessions to a data store
            </summary>
            <param name="sExportFormat">Shortname of the format</param>
            <param name="oSessions">Array of Sessions being exported</param>
            <param name="dictOptions">Dictionary of options that the Exporter class may use</param>
            <param name="evtProgressNotifications">Callback event on which progress is reported or the host may cancel</param>
            <returns>TRUE if the export was successful</returns>
        </member>
        <member name="T:Fiddler.ProgressCallbackEventArgs">
            <summary>
            EventArgs class for the ISessionImporter and ISessionExporter interface callbacks
            </summary>
        </member>
        <member name="M:Fiddler.ProgressCallbackEventArgs.#ctor(System.Single,System.String)">
            <summary>
            Progress Callback 
            </summary>
            <param name="flCompletionRatio">Float indicating completion ratio, 0.0 to 1.0. Set to 0 if unknown.</param>
            <param name="sProgressText">Short string describing current operation, progress, etc</param>
        </member>
        <member name="P:Fiddler.ProgressCallbackEventArgs.Cancel">
            <summary>
            Set to TRUE to request that Import/Export process be aborted as soon as convenient
            </summary>
        </member>
        <member name="P:Fiddler.ProgressCallbackEventArgs.ProgressText">
            <summary>
            The string message of the notification
            </summary>
        </member>
        <member name="P:Fiddler.ProgressCallbackEventArgs.PercentComplete">
            <summary>
            The percentage completed
            </summary>
        </member>
        <member name="T:Fiddler.FiddlerTranscoders">
            <summary>
            Fiddler Transcoders allow import and export of Sessions from Fiddler
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.#ctor">
            <summary>
            Create the FiddlerTranscoders object
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.ToString">
            <summary>
            List all of the Transcoder objects that are loaded
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.ImportTranscoders(System.String)">
            <summary>
            Add Import/Export encoders to FiddlerApplication.oTranscoders
            </summary>
            <param name="sAssemblyPath">Assembly to import exporters and importers</param>
            <returns>FALSE on obvious errors</returns>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.ImportTranscoders(System.Reflection.Assembly)">
            <summary>
            Add Import/Export encoders to FiddlerApplication.oTranscoders
            </summary>
            <param name="assemblyInput">Assembly to scan for transcoders</param>
            <returns>FALSE on obvious errors</returns>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.ScanPathForTranscoders(System.String,System.Boolean)">
            <summary>
            Loads any assembly in the specified path that ends with .dll and does not start with "_", checks that a compatible version requirement was specified, 
            and adds the importer and exporters within to the collection.
            </summary>
            <param name="sPath">The path to scan for extensions</param>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.EnsureTranscoders">
            <summary>
            Ensures that Import/Export Transcoders have been loaded
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.GetExporter(System.String)">
            <summary>
            Returns a TranscoderTuple willing to handle the specified format
            </summary>
            <param name="sExportFormat">The Format</param>
            <returns>TranscoderTuple, or null</returns>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.GetImporter(System.String)">
            <summary>
            Returns a TranscoderTuple willing to handle the specified format
            </summary>
            <param name="sImportFormat">The Format</param>
            <returns>TranscoderTuple, or null</returns>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.AddToImportOrExportCollection(System.Collections.Generic.Dictionary{System.String,Fiddler.TranscoderTuple},System.Type)">
            <summary>
            Gets the format list of the specified type and adds that type to the collection.
            </summary>
            <param name="oCollection"></param>
            <param name="t"></param>
            <returns>TRUE if any formats were found; FALSE otherwise</returns>
        </member>
        <member name="M:Fiddler.FiddlerTranscoders.Dispose">
            <summary>
            Clear Importer and Exporter collections
            </summary>
        </member>
        <member name="P:Fiddler.FiddlerTranscoders.hasImporters">
            <summary>
            True if one or more classes implementing ISessionImporter are available.
            </summary>
        </member>
        <member name="P:Fiddler.FiddlerTranscoders.hasExporters">
            <summary>
            True if one or more classes implementing ISessionImporter are available.
            </summary>
        </member>
        <member name="T:Fiddler.CodeDescription">
            <summary>
            CodeDescription attributes are used to enable the FiddlerScript Editor to describe available methods, properties, fields, and events.
            </summary>
        </member>
        <member name="M:Fiddler.CodeDescription.#ctor(System.String)">
            <summary>
            CodeDescription attributes should be constructed by annotating a property, method, or field.
            </summary>
            <param name="desc">The descriptive string which should be displayed for this this property, method, or field</param>
        </member>
        <member name="P:Fiddler.CodeDescription.Description">
            <summary>
            The descriptive string which should be displayed for this this property, method, or field
            </summary>
        </member>
        <member name="T:Fiddler.FiddlerCoreStartupFlags">
            <summary>
            Flags that can be passed into the Startup method
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.None">
            <summary>
            No options. 
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.RegisterAsSystemProxy">
            <summary>
            Register with WinINET as the System Proxy
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.DecryptSSL">
            <summary>
            Decrypt HTTPS Traffic
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.AllowRemoteClients">
            <summary>
            Accept requests from remote computers or devices. WARNING: Security Impact
            </summary>
            <remarks>
            Use caution when allowing Remote Clients to connect. If a hostile computer is able to proxy his traffic through your
            FiddlerCore instance, he could circumvent IPSec traffic rules, circumvent intranet firewalls, consume memory on your PC, etc.
            </remarks>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.ChainToUpstreamGateway">
            <summary>
            Set this flag to forward requests to any upstream gateway
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.MonitorAllConnections">
            <summary>
            Set this flag to set all WinINET connections to use Fiddler, otherwise only the Local LAN is pointed to Fiddler
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerCoreStartupFlags.Default">
            <summary>
            Start FiddlerCore with the default set of options (RegisterAsSystemProxy | DecryptSSL | ChainToUpstreamGateway | MonitorAllConnections | CaptureLocalhostTraffic | OptimizeThreadPool)
            </summary>
        </member>
        <member name="T:Fiddler.SimpleEventHandler">
            <summary>
            A simple delegate for functions which accept no parameters. (MethodInvoker is the identical Framework version of this delegate)
            </summary>
        </member>
        <member name="T:Fiddler.CalculateReportHandler">
            <summary>
            An event handling delegate which is called during report calculation with the set of sessions being evaluated.
            </summary>
            <param name="_arrSessions">The sessions in this report.</param>
        </member>
        <member name="T:Fiddler.SessionStateHandler">
            <summary>
            An event handling delegate which is called as a part of the HTTP pipeline at various stages.
            </summary>
            <param name="oSession">The Web Session in the pipeline.</param>
        </member>
        <member name="T:Fiddler.FiddlerApplication">
            <summary>
            This class acts as the central point for script/extensions to interact with Fiddler components.
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerApplication.isClosing">
            <summary>
            TRUE if Fiddler is currently shutting down. Suspend all work that won't have side-effects.
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerApplication.oDefaultClientCertificate">
            <summary>
            The default certificate used for client authentication
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerApplication.Janitor">
            <summary>
            Fiddler's "Janitor" clears up unneeded resources (e.g. server sockets, DNS entries)
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication.GetVersionString">
            <summary>
            Gets Fiddler* version info
            </summary>
            <returns>A string indicating the build/flavor of the Fiddler* assembly</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.SetAppDisplayName(System.String)">
            <summary>
            Set the DisplayName for the application
            </summary>
            <param name="sAppName">1 to 64 character name to be displayed in error messages, etc</param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.GetDetailedInfo">
            <summary>
            Returns Help/About information.
            </summary>
            <returns>Display string describing the current Fiddler instance.</returns>
        </member>
        <member name="F:Fiddler.FiddlerApplication.oProxy">
            <summary>
            Fiddler's core proxy object.
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerApplication.oTranscoders">
            <summary>
            Fiddler Import/Export Transcoders
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerApplication.slLeakedFiles">
            <summary>
            List of "leaked" temporary files to be deleted as Fiddler exits.
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication.IsStarted">
            <summary>
            Checks if FiddlerCore is running.
            </summary>
            <returns>TRUE if FiddlerCore is started/listening; FALSE otherwise.</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.IsSystemProxy">
            <summary>
            Checks if FiddlerCore is running and registered as the System Proxy.
            </summary>
            <returns>TRUE if FiddlerCore IsStarted AND registered as the system proxy; FALSE otherwise.</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.Startup(System.Int32,Fiddler.FiddlerCoreStartupFlags)">
            <summary>
            Recommended way to Start FiddlerCore listening on the specified port
            </summary>
            <param name="iListenPort">The port</param>
            <param name="oFlags">The FiddlerCoreStartupFlags option you want to set; FiddlerCoreStartupFlags.Default is recommended</param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.Startup(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Start the FiddlerCore engine; this overload is NOT RECOMMENDED
            </summary>
            <param name="iListenPort"></param>
            <param name="bRegisterAsSystemProxy"></param>
            <param name="bDecryptSSL"></param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.Startup(System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Start the FiddlerCore engine; this overload is NOT RECOMMENDED
            </summary>
            <param name="iListenPort">Port to Listen on.</param>
            <param name="bRegisterAsSystemProxy">Boolean indicating if FiddlerCore should register as the system proxy.</param>
            <param name="bDecryptSSL">Boolean indicating if FiddlerCore should decrypt secure traffic. If true, requires MakeCert.exe in the Application folder.</param>
            <param name="bAllowRemote">Boolean indicating if FiddlerCore should accept connections from remote computers. Note: You must ensure Firewall is configured to allow such connections to your program.</param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.CreateProxyEndpoint(System.Int32,System.Boolean,System.String)">
            <summary>
            Start a new proxy endpoint instance, listening on the specified port
            </summary>
            <param name="iPort">The port to listen on</param>
            <param name="bAllowRemote">TRUE if remote clients should be permitted to connect to this endpoint</param>
            <param name="sHTTPSHostname">A Hostname (e.g. EXAMPLE.com) if this endpoint should be treated as a HTTPS Server</param>
            <returns>A Proxy object, or null if unsuccessful</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.CreateProxyEndpoint(System.Int32,System.Boolean,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Start a new proxy endpoint instance, listening on the specified port
            </summary>
            <param name="iPort">The port to listen on</param>
            <param name="bAllowRemote">TRUE if remote clients should be permitted to connect to this endpoint</param>
            <param name="certHTTPS">A certificate to return when clients connect, or null</param>
            <returns>A Proxy object, or null if unsuccessful</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.Shutdown">
            <summary>
            Shuts down the FiddlerCore proxy and disposes it. Note: If there's any traffic in progress while you're calling this method,
            your background threads are likely to blow up with ObjectDisposedExceptions or NullReferenceExceptions. In many cases, you're
            better off simply calling oProxy.Detach() and letting the garbage collector clean up when your program exits.
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication.DoReadResponseBuffer(Fiddler.Session,System.Byte[],System.Int32)">
            <summary>
            Notify a listener that a block of a response was read.
            </summary>
            <param name="oS">The session for which the response is being read</param>
            <param name="arrBytes">byte buffer (not completely full)</param>
            <param name="cBytes">bytes set.</param>
            <returns>FALSE if AbortReading was set</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.DoReadRequestBuffer(Fiddler.Session,System.Byte[],System.Int32)">
            <summary>
            Notify a listener that a block of a request was read. Note that this event may fire with overlapping blocks of data but
            different sessions if the client uses HTTP Pipelining.
            </summary>
            <param name="oS">The session for which the response is being read</param>
            <param name="arrBytes">byte buffer (not completely full)</param>
            <param name="cBytes">bytes set.</param>
            <returns>FALSE if AbortReading was set</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.DoExport(System.String,Fiddler.Session[],System.Collections.Generic.Dictionary{System.String,System.Object},System.EventHandler{Fiddler.ProgressCallbackEventArgs})">
            <summary>
            Export Sessions in the specified format
            </summary>
            <param name="sExportFormat">Shortname of desired format</param>
            <param name="oSessions">Sessions to export</param>
            <param name="dictOptions">Options to pass to the ISessionExport interface</param>
            <param name="ehPCEA">Your callback event handler, or NULL to allow Fiddler to handle</param>
            <returns>TRUE if successful, FALSE if desired format doesn't exist or other error occurs</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.DoImport(System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Object},System.EventHandler{Fiddler.ProgressCallbackEventArgs})">
            <summary>
            Calls a Fiddler Session Importer and returns the list of loaded Sessions.
            </summary>
            <param name="sImportFormat">String naming the Import format, e.g. HTTPArchive</param>
            <param name="bAddToSessionList">Should sessions be added to WebSessions list? (Not meaningful for FiddlerCore)</param>
            <param name="dictOptions">Dictionary of Options to pass to the Transcoder</param>
            <param name="ehPCEA">Your callback event handler, or NULL to allow Fiddler to handle</param>
            <returns>Loaded Session[], or null on Failure</returns>
        </member>
        <member name="M:Fiddler.FiddlerApplication.ResetSessionCounter">
            <summary>
            Reset the SessionID counter to 0. This method can lead to confusing UI, so call sparingly.
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication.DoNotifyUser(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxIcon)">
            <summary>
            Log a notification to the OnNotification handler and, if not in quiet mode, show a MessageBox
            </summary>
            <param name="ownerWnd">Window to which this notification should be parented, or null</param>
            <param name="sMessage">Text in the Window</param>
            <param name="sTitle">Title of the Window</param>
            <param name="oIcon">Icon for the window</param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.ReportException(System.Exception,System.String)">
            <summary>
            Report an exception to the user.
            </summary>
            <param name="eX">The Exception</param>
            <param name="sTitle">The Title of the dialog</param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.ReportException(System.Exception,System.String,System.String)">
            <summary>
            Report an exception to the user.
            </summary>
            <param name="eX">The Exception</param>
            <param name="sTitle">The Title of the dialog</param>
            <param name="sCallerMessage">The intro text to show. If null or empty, the default "Fiddler has encountered an unexpected... " message is shown. </param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.HandleHTTPError(Fiddler.Session,Fiddler.SessionFlags,System.Boolean,System.Boolean,System.String)">
            <summary>
            Show the user a message when an HTTP Error was encountered
            </summary>
            <param name="oSession">Session with error</param>
            <param name="bPoisonClientConnection">Set to true to prevent pooling/reuse of client connection</param>
            <param name="flagViolation">The SessionFlag which should be set to log this violation</param>
            <param name="bPoisonServerConnection">Set to true to prevent pooling/reuse of server connection</param>
            <param name="sMessage">Information about the problem</param>
        </member>
        <member name="F:Fiddler.FiddlerApplication.iPID">
            <summary>
            Process ID of this Fiddler instance
            </summary>
        </member>
        <member name="F:Fiddler.FiddlerApplication.sProcessInfo">
            <summary>
            processname:PID of Fiddler
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication._SetXceedLicenseKeys">
            <summary>
            We really don't want this method to get inlined, because that would cause the Xceed DLLs to get loaded in the Main() function instead
            of when _SetXceedLicenseKeys is called; that, in turn, would delay the SplashScreen.
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication.LogAddonException(System.Exception,System.String)">
            <summary>
            Used to track errors with addons.
            </summary>
            <param name="eX"></param>
            <param name="sTitle"></param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.LogLeakedFile(System.String)">
            <summary>
            Record that a temporary file was created and handed to an external tool. We'll do our best to delete this file on exit.
            </summary>
            <param name="sTempFile">The filename of the file to be deleted</param>
        </member>
        <member name="M:Fiddler.FiddlerApplication.WipeLeakedFiles">
            <summary>
            Clean up any Temporary files that were created
            </summary>
        </member>
        <member name="M:Fiddler.FiddlerApplication.Supports(System.String)">
            <summary>
            Does this Fiddler instance support the specified feature?
            </summary>
            <param name="pFeature">Feature name (e.g. "bzip2")</param>
            <returns>TRUE if the specified feature is supported; false otherwise</returns>
        </member>
        <member name="P:Fiddler.FiddlerApplication.Log">
            <summary>
            Fiddler's logging system
            </summary>
        </member>
        <member name="P:Fiddler.FiddlerApplication.Prefs">
            <summary>
            Fiddler's Preferences collection. Learn more at http://fiddler.wikidot.com/prefs
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.OnReadResponseBuffer">
            <summary>
            This event fires each time FiddlerCore reads data from network for the server's response. Note that this data
            is not formatted in any way, and must be parsed by the recipient.
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.OnReadRequestBuffer">
            <summary>
            This event fires each time FiddlerCore reads data from network for the client's request. Note that this data
            is not formatted in any way, and must be parsed by the recipient.
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.BeforeRequest">
            <summary>
            This event fires when a client request is received by Fiddler
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.BeforeResponse">
            <summary>
            This event fires when a server response is received by Fiddler
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.RequestHeadersAvailable">
            <summary>
            This event fires when Request Headers are available
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.ResponseHeadersAvailable">
            <summary>
            This event fires when Response Headers are available
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.BeforeReturningError">
            <summary>
            This event fires when an error response is generated by Fiddler
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.OnWebSocketMessage">
            <summary>
            This event fires when Fiddler captures a WebSocket message
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.AfterSessionComplete">
            <summary>
            This event fires when a session has been completed
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.FiddlerAttach">
            <summary>
            Sync this event to be notified when FiddlerCore has attached as the system proxy.")]
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.FiddlerDetach">
            <summary>
            Sync this event to be notified when FiddlerCore has detached as the system proxy.
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.AfterSocketConnect">
            <summary>
            Fired each time Fiddler successfully establishes a TCP/IP connection
            </summary>
        </member>
        <member name="E:Fiddler.FiddlerApplication.AfterSocketAccept">
            <summary>
            Fired each time Fiddler successfully accepts a TCP/IP connection
            </summary>
        </member>
        <member name="P:Fiddler.ConnectionEventArgs.Connection">
            <summary>
            The Socket which was just Connected or Accepted
            </summary>
        </member>
        <member name="P:Fiddler.ConnectionEventArgs.OwnerSession">
            <summary>
            The Session which owns the this new connection
            </summary>
        </member>
        <member name="T:Fiddler.NotificationEventArgs">
            <summary>
            EventArgs class for the OnNotification handler
            </summary>
        </member>
        <member name="P:Fiddler.NotificationEventArgs.NotifyString">
            <summary>
            The string message of the notification
            </summary>
        </member>
        <member name="T:Fiddler.CertificateValidity">
            <summary>
            Enumeration of possible responses specified by the ValidateServerCertificateEventArgs as modified by FiddlerApplication's <see cref="E:Fiddler.FiddlerApplication.OnValidateServerCertificate">OnValidateServerCertificate event</see>  
            </summary>
        </member>
        <member name="F:Fiddler.CertificateValidity.Default">
            <summary>
            The certificate will be considered valid if CertificatePolicyErrors == SslPolicyErrors.None, otherwise the certificate will be invalid unless the user manually allows the certificate.
            </summary>
        </member>
        <member name="F:Fiddler.CertificateValidity.ConfirmWithUser">
            <summary>
            The certificate will be confirmed with the user even if CertificatePolicyErrors == SslPolicyErrors.None.
            Note: FiddlerCore does not support user-prompting and will always treat this status as ForceInvalid.
            </summary>
        </member>
        <member name="F:Fiddler.CertificateValidity.ForceInvalid">
            <summary>
            Force the certificate to be considered Invalid, regardless of the value of CertificatePolicyErrors.
            </summary>
        </member>
        <member name="F:Fiddler.CertificateValidity.ForceValid">
            <summary>
            Force the certificate to be considered Valid, regardless of the value of CertificatePolicyErrors.
            </summary>
        </member>
        <member name="T:Fiddler.ValidateServerCertificateEventArgs">
            <summary>
            These EventArgs are passed to the FiddlerApplication.OnValidateServerCertificate event handler when a server-provided HTTPS certificate is evaluated
            </summary>
        </member>
        <member name="M:Fiddler.ValidateServerCertificateEventArgs.#ctor(Fiddler.Session,System.String,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            EventArgs for the ValidateServerCertificateEvent that allows host to override default certificate handling policy
            </summary>
            <param name="inSession">The session</param>
            <param name="inExpectedCN">The CN expected for this session</param>
            <param name="inServerCertificate">The certificate provided by the server</param>
            <param name="inServerCertificateChain">The certificate chain of that certificate</param>
            <param name="inSslPolicyErrors">Errors from default validation</param>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.TargetPort">
            <summary>
            The port to which this request was targeted
            </summary>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.ExpectedCN">
            <summary>
            The SubjectCN (e.g. Hostname) that should be expected on this HTTPS connection, based on the request's Host property.
            </summary>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.Session">
            <summary>
            The Session for which a HTTPS certificate was received.
            </summary>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.ServerCertificateChain">
            <summary>
            The server's certificate chain.
            </summary>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.CertificatePolicyErrors">
            <summary>
            The SslPolicyErrors found during default certificate evaluation.
            </summary>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.ValidityState">
            <summary>
            Set this property to override the certificate validity
            </summary>
        </member>
        <member name="P:Fiddler.ValidateServerCertificateEventArgs.ServerCertificate">
            <summary>
            The X509Certificate provided by the server to vouch for its authenticity
            </summary>
        </member>
        <member name="T:Fiddler.CacheClearEventArgs">
            <summary>
            These EventArgs are constructed when FiddlerApplication.OnClearCache is called.
            </summary>
        </member>
        <member name="M:Fiddler.CacheClearEventArgs.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Constructs the Event Args
            </summary>
            <param name="bClearFiles">Should Cache Files be cleared?</param>
            <param name="bClearCookies">Should Cookies be cleared?</param>
        </member>
        <member name="P:Fiddler.CacheClearEventArgs.ClearCacheFiles">
            <summary>
            True if the user wants cache files to be cleared
            </summary>
        </member>
        <member name="P:Fiddler.CacheClearEventArgs.ClearCookies">
            <summary>
            True if the user wants cookies to be cleared
            </summary>
        </member>
        <member name="T:Fiddler.RawReadEventArgs">
            <summary>
            When the FiddlerApplication.OnReadResponseBuffer event fires, the raw bytes are available via this object.
            </summary>
        </member>
        <member name="P:Fiddler.RawReadEventArgs.AbortReading">
            <summary>
            Set to TRUE to request that upload or download process be aborted as soon as convenient
            </summary>
        </member>
        <member name="P:Fiddler.RawReadEventArgs.sessionOwner">
            <summary>
            Session for which this responseRead is occurring
            </summary>
        </member>
        <member name="P:Fiddler.RawReadEventArgs.arrDataBuffer">
            <summary>
            Byte buffer returned from read. Note: Always of fixed size, check iCountOfBytes to see which bytes were set
            </summary>
        </member>
        <member name="P:Fiddler.RawReadEventArgs.iCountOfBytes">
            <summary>
            Count of latest read from Socket. If less than 1, response was ended.
            </summary>
        </member>
        <member name="T:Fiddler.frmPrompt">
            <summary>
            The frmPrompt class is used to get information from the client. It's primarily used by calling one of the <see cref="M:Fiddler.frmPrompt.GetUserString(System.String,System.String,System.String)"/> static functions.
            </summary>
        </member>
        <member name="F:Fiddler.frmPrompt.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Fiddler.frmPrompt.GetUserString(System.String,System.String,System.String)">
            <summary>
            Get a string value from the user.
            </summary>
            <param name="sTitle">The title of the dialog</param>
            <param name="sPrompt">The prompt text</param>
            <param name="sDefault">The default string value</param>
            <returns>The value entered by the user (or default, if unmodified)</returns>
        </member>
        <member name="M:Fiddler.frmPrompt.GetUserString(System.String,System.String,System.String,System.Boolean)">
            <summary>
            GetUserString prompts the user for a string.
            </summary>
            <param name="sTitle">Title of the dialog</param>
            <param name="sPrompt">The prompt text in the dialog</param>
            <param name="sDefault">The default response</param>
            <param name="bReturnNullIfCancelled">If true, will return null if user hits cancel. Else returns sDefault.</param>
            <returns>The user's result, or null if user cancelled and bReturnNullIfCancelled set.</returns>
        </member>
        <member name="M:Fiddler.frmPrompt.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:Fiddler.frmPrompt.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Fiddler.FTPGateway">
            <summary>
            This FTP Gateway class is used if Fiddler is configured as the FTP proxy and there's no upstream gateway configured. 
            Fiddler must act as a HTTP->FTP protocol converter, which it does by using the .NET FTP classes.
            </summary>
        </member>
        <member name="M:Fiddler.FTPGateway.MakeFTPRequest(Fiddler.Session,Fiddler.PipeReadBuffer,Fiddler.HTTPResponseHeaders@)">
            <summary>
            Make a FTP request using the .NET FTPWebRequest class.
            WARNING: This method will throw.
            </summary>
            <param name="oSession">Session bearing an FTP request</param>
            <param name="buffBody">Returns Response body stream</param>
            <param name="oRH">Returns generated Response headers</param>
        </member>
        <member name="T:Fiddler.GenericTunnel">
            <summary>
            The GenericTunnel class represents a "blind tunnel" to shuffle bytes between a client and the server.
            </summary>
        </member>
        <member name="F:Fiddler.GenericTunnel.bResponseStreamStarted">
            <summary>
            Is streaming started in the downstream direction?
            </summary>
        </member>
        <member name="F:Fiddler.GenericTunnel._lngEgressByteCount">
            <summary>
            Number of bytes received from the client
            </summary>
        </member>
        <member name="F:Fiddler.GenericTunnel._lngIngressByteCount">
            <summary>
            Number of bytes received from the server
            </summary>
        </member>
        <member name="M:Fiddler.GenericTunnel.CreateTunnel(Fiddler.Session,System.Boolean)">
            <summary>
            This "Factory" method creates a new HTTPS Tunnel and executes it on a background (non-pooled) thread.
            </summary>
            <param name="oSession">The Session containing the HTTP CONNECT request</param>
        </member>
        <member name="M:Fiddler.GenericTunnel.#ctor(Fiddler.Session,Fiddler.ClientPipe,Fiddler.ServerPipe,System.Boolean)">
            <summary>
            Creates a tunnel. External callers instead use the CreateTunnel static method.
            </summary>
            <param name="oSess">The session for which this tunnel was initially created.</param>
            <param name="oFrom">Client Pipe</param>
            <param name="oTo">Server Pipe</param>
        </member>
        <member name="M:Fiddler.GenericTunnel.WaitForCompletion">
            <summary>
            This function keeps the thread alive until it is signaled that the traffic is complete
            </summary>
        </member>
        <member name="M:Fiddler.GenericTunnel.RunTunnel">
            <summary>
            Executes the HTTPS tunnel inside an All-it-can-eat exception handler.
            Call from a background thread.
            </summary>
        </member>
        <member name="M:Fiddler.GenericTunnel.DoTunnel">
            <summary>
            Executes the WebSocket tunnel on a background thread
            </summary>
        </member>
        <member name="M:Fiddler.GenericTunnel.BeginResponseStreaming">
            <summary>
            Instructs the tunnel to take over the server pipe and begin streaming responses to the client
            </summary>
        </member>
        <member name="M:Fiddler.GenericTunnel.CloseTunnel">
            <summary>
            Close the HTTPS tunnel and signal the event to let the service thread die.
            WARNING: This MUST not be allowed to throw any exceptions, because it will do so on threads that don't catch them, and this will kill the application.
            </summary>
        </member>
        <member name="M:Fiddler.GenericTunnel.OnClientReceive(System.IAsyncResult)">
            <summary>
             Called when we have received data from the local client.
             Incoming data will immediately be forwarded to the remote host.
            </summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.GenericTunnel.OnClientSent(System.IAsyncResult)">
            <summary>Called when we have sent data to the local client.<br>When all the data has been sent, we will start receiving again from the remote host.</br></summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.GenericTunnel.OnRemoteSent(System.IAsyncResult)">
            <summary>Called when we have sent data to the remote host.<br>When all the data has been sent, we will start receiving again from the local client.</br></summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.GenericTunnel.OnRemoteReceive(System.IAsyncResult)">
            <summary>Called when we have received data from the remote host.<br>Incoming data will immediately be forwarded to the local client.</br></summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="P:Fiddler.GenericTunnel.IngressByteCount">
            <summary>
            Returns number of bytes sent from the Server to the Client
            </summary>
        </member>
        <member name="P:Fiddler.GenericTunnel.EgressByteCount">
            <summary>
            Returns number of bytes sent from the Client to the Server
            </summary>
        </member>
        <member name="T:Fiddler.HostList">
            <summary>
            The HostList allows fast determination of whether a given host is in the list. It supports leading wildcards (e.g. *.foo.com), and the special tokens  &lt;local&gt; &lt;nonlocal&gt; and &lt;loopback&gt;.
            Note: List is *not* threadsafe; instead of updating it, construct a new one.
            </summary>
        </member>
        <member name="M:Fiddler.HostList.#ctor">
            <summary>
            Generate an empty HostList
            </summary>
        </member>
        <member name="M:Fiddler.HostList.#ctor(System.String)">
            <summary>
            Create a hostlist and assign it an initial set of sites
            </summary>
            <param name="sInitialList">List of hostnames, including leading wildcards, and optional port specifier. Special tokens are *, &lt;local&gt;, &lt;nonlocal&gt;, and &lt;loopback&gt;.</param>
        </member>
        <member name="M:Fiddler.HostList.Clear">
            <summary>
            Clear the HostList
            </summary>
        </member>
        <member name="M:Fiddler.HostList.AssignFromString(System.String)">
            <summary>
            Clear the List and assign the new string as the contents of the list.
            </summary>
            <param name="sIn">List of hostnames, including leading wildcards, and optional port specifier. Special tokens are *, &lt;local&gt;, &lt;nonlocal&gt;, and &lt;loopback&gt;.</param>
            <returns>TRUE if the list was constructed without errors</returns>
        </member>
        <member name="M:Fiddler.HostList.AssignFromString(System.String,System.String@)">
            <summary>
            Clear the list and assign the new string as the contents of the list.
            </summary>
            <param name="sIn">List of hostnames, including leading wildcards, and optional port specifier. Special tokens are *, &lt;local&gt;, &lt;nonlocal&gt;, and &lt;loopback&gt;.</param>
            <param name="sErrors">Outparam string containing list of parsing errors</param>
            <returns>TRUE if the list was constructed without errors</returns>
        </member>
        <member name="M:Fiddler.HostList.ToString">
            <summary>
            Return the current list of rules as a string
            </summary>
            <returns>String containing current rules, using "; " as a delimiter between entries</returns>
        </member>
        <member name="M:Fiddler.HostList.ContainsHost(System.String)">
            <summary>
            Determine if a given Host is in the list
            </summary>
            <param name="sHost">A Host string, potentially including a port</param>
            <returns>TRUE if the Host's hostname matches a rule in the list</returns>
        </member>
        <member name="M:Fiddler.HostList.ContainsHostname(System.String)">
            <summary>
            Determine if a given Hostname is in the list
            </summary>
            <param name="sHostname">A hostname, NOT including a port</param>
            <returns>TRUE if the hostname matches a rule in the list</returns>
        </member>
        <member name="M:Fiddler.HostList.ContainsHost(System.String,System.Int32)">
            <summary>
            Determine if a given Host:Port pair matches an entry in the list
            </summary>
            <param name="sHostname">A hostname, NOT including the port</param>
            <param name="iPort">The port</param>
            <returns>TRUE if the hostname matches a rule in the list</returns>
        </member>
        <member name="T:Fiddler.HostList.HostPortTuple">
            <summary>
            This private tuple allows us to associate a Hostname and a Port
            </summary>
        </member>
        <member name="F:Fiddler.HostList.HostPortTuple._iPort">
            <summary>
            Port specified in the rule
            </summary>
        </member>
        <member name="F:Fiddler.HostList.HostPortTuple._sHostname">
            <summary>
            Hostname specified in the rule
            </summary>
        </member>
        <member name="M:Fiddler.HostList.HostPortTuple.#ctor(System.String,System.Int32)">
            <summary>
            Create a new HostPortTuple
            </summary>
        </member>
        <member name="T:Fiddler.HTTPResponseHeaders">
            <summary>
            HTTP Response headers object
            </summary>
        </member>
        <member name="T:Fiddler.HTTPHeaders">
            <summary>
            Base class for RequestHeaders and ResponseHeaders
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaders.GetReaderLock">
            <summary>
            Get the Reader Lock if you plan to enumerate the Storage collection.
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaders.GetWriterLock">
            <summary>
            Get the Writer Lock if you plan to change the Storage collection.
            NB: You only need this lock if you plan to change the collection itself; you can party on the items in the collection if you like without locking.
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaders.FreeWriterLock">
            <summary>
            If you get the Writer lock, Free it ASAP or you're going to hang or deadlock the Session
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaders._HeaderEncoding">
            <summary>
            Text encoding to be used when converting this header object to/from a byte array
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaders.HTTPVersion">
            <summary>
            HTTP version (e.g. HTTP/1.1)
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaders.storage">
            <summary>
            Storage for individual HTTPHeaderItems in this header collection
            NB: Using a list is important, as order can matter
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaders.ByteCount">
            <summary>
            Get byte count of this HTTP header instance.
            NOTE: This method should've been abstract.
            </summary>
            <returns>Byte Count</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.Count">
            <summary>
            Number of HTTP headers
            </summary>
            <returns>Number of HTTP headers</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.FindAll(System.String)">
            <summary>
            Returns all instances of the named header
            </summary>
            <param name="sHeaderName">Header name</param>
            <returns>List of instances of the named header</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.ToArray">
            <summary>
            Copies the Headers to a new array.
            Prefer this method over the enumerator to avoid cross-thread problems.
            </summary>
            <returns>An array containing HTTPHeaderItems</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.AllValues(System.String)">
            <summary>
            Returns all values of the named header in a single string, delimited by commas
            </summary>
            <param name="sHeaderName">Header</param>
            <returns>Each, Header's, Value</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.CountOf(System.String)">
            <summary>
            Returns the count of instances of the named header
            </summary>
            <param name="sHeaderName">Header name</param>
            <returns>Count of instances of the named header</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.GetEnumerator">
            <summary>
            Enumerator for HTTPHeader storage collection
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.Add(System.String,System.String)">
            <summary>
            Adds a new header containing the specified name and value.
            </summary>
            <param name="sHeaderName">Name of the header to add.</param>
            <param name="sValue">Value of the header.</param>
            <returns>Returns the newly-created HTTPHeaderItem.</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.AddRange(System.Collections.Generic.IEnumerable{Fiddler.HTTPHeaderItem})">
            <summary>
            Adds one or more headers
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaders.GetTokenValue(System.String,System.String)">
            <summary>
            Returns the Value from a token in the header. Correctly handles double-quoted strings. Requires semicolon for delimiting tokens
            Limitation: FAILS if semicolon is in token's value, even if quoted. 
            FAILS in the case of crazy headers, e.g. Header: Blah="SoughtToken=Blah" SoughtToken=MissedMe
            
            We really need a "proper" header parser
            </summary>
            <param name="sHeaderName">Name of the header</param>
            <param name="sTokenName">Name of the token</param>
            <returns>Value of the token if present; otherwise, null</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.Exists(System.String)">
            <summary>
            Determines if the Headers collection contains a header of the specified name, with any value.
            </summary>
            <param name="sHeaderName">The name of the header to check. (case insensitive)</param>
            <returns>True, if the header exists.</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.ExistsAny(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines if the Headers collection contains any header from the specified list, with any value.
            </summary>
            <param name="sHeaders">list of headers</param>
            <returns>True, if any named header exists.</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.ExistsAndContains(System.String,System.String)">
            <summary>
            Determines if the Headers collection contains one or more headers of the specified name, and 
            sHeaderValue is part of one of those Headers' value.
            </summary>
            <param name="sHeaderName">The name of the header to check. (case insensitive)</param>
            <param name="sHeaderValue">The partial header value. (case insensitive)</param>
            <returns>True if the header is found and the value case-insensitively contains the parameter</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.ExistsAndEquals(System.String,System.String)">
            <summary>
            Determines if the Headers collection contains a header of the specified name, and sHeaderValue=Header's value. Similar
            to a case-insensitive version of: headers[sHeaderName]==sHeaderValue, although it checks all instances of the named header.
            </summary>
            <param name="sHeaderName">The name of the header to check. (case insensitive)</param>
            <param name="sHeaderValue">The full header value. (case insensitive)</param>
            <returns>True if the header is found and the value case-insensitively matches the parameter</returns>
        </member>
        <member name="M:Fiddler.HTTPHeaders.Remove(System.String)">
            <summary>
            Removes all headers from the header collection which have the specified name.
            </summary>
            <param name="sHeaderName">The name of the header to remove. (case insensitive)</param>
        </member>
        <member name="M:Fiddler.HTTPHeaders.RemoveRange(System.String[])">
            <summary>
            Removes all headers from the header collection which have the specified names.
            </summary>
            <param name="sHeaderName">Array of names of headers to remove. (case insensitive)</param>
        </member>
        <member name="M:Fiddler.HTTPHeaders.Remove(Fiddler.HTTPHeaderItem)">
            <summary>
            Removes a HTTPHeader item from the collection
            </summary>
            <param name="oRemove">The HTTPHeader item to be removed</param>
        </member>
        <member name="M:Fiddler.HTTPHeaders.RemoveAll">
            <summary>
            Removes all HTTPHeader items from the collection
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaders.RenameHeaderItems(System.String,System.String)">
            <summary>
            Renames all headers in the header collection which have the specified name.
            </summary>
            <param name="sOldHeaderName">The name of the header to rename. (case insensitive)</param>
            <param name="sNewHeaderName">The new name for the header.</param>
            <returns>True if one or more replacements were made.</returns>
        </member>
        <member name="P:Fiddler.HTTPHeaders.Item(System.String)">
            <summary>
            Gets or sets the value of a header. In the case of Gets, the value of the first header of that name is returned.
            If the header does not exist, returns null.
            In the case of Sets, the value of the first header of that name is updated.  
            If the header does not exist, it is added.
            </summary>
        </member>
        <member name="P:Fiddler.HTTPHeaders.Item(System.Int32)">
            <summary>
            Indexer property. Returns HTTPHeaderItem by index. Throws Exception if index out of bounds
            </summary>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.GetEnumerator">
            <summary>
            Protect your enumeration using GetReaderLock
            </summary>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Protect your enumeration using GetReaderLock
            </summary>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.Clone">
            <summary>
            Clone this HTTPResponseHeaders object and return the result cast to an Object
            </summary>
            <returns>The new response headers object, cast to an object</returns>
        </member>
        <member name="F:Fiddler.HTTPResponseHeaders.HTTPResponseCode">
            <summary>
            Status code from HTTP Response. If setting, also set HTTPResponseStatus too!
            </summary>
        </member>
        <member name="F:Fiddler.HTTPResponseHeaders.HTTPResponseStatus">
            <summary>
            Code AND Description of Response Status (e.g. '200 OK').
            </summary>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.SetStatus(System.Int32,System.String)">
            <summary>
            Update the response status code and text
            </summary>
            <param name="iCode">HTTP Status code (e.g. 401)</param>
            <param name="sDescription">HTTP Status text (e.g. "Access Denied")</param>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.#ctor">
            <summary>
            Constructor for HTTP Response headers object
            </summary>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.#ctor(System.Text.Encoding)">
            <summary>
            Constructor for HTTP Response headers object
            </summary>
            <param name="encodingForHeaders">Text encoding to be used for this set of Headers when converting to a byte array</param>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.ToByteArray(System.Boolean,System.Boolean)">
            <summary>
            Returns a byte array representing the HTTP headers.
            </summary>
            <param name="prependStatusLine">TRUE if the response status line should be included</param>
            <param name="appendEmptyLine">TRUE if there should be a trailing \r\n byte sequence included</param>
            <returns>Byte[] containing the headers</returns>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a string containing http headers
            </summary>
            <param name="prependStatusLine">TRUE if the response status line should be included</param>
            <param name="appendEmptyLine">TRUE if there should be a trailing CRLF included</param>
            <returns>String containing http headers</returns>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.ToString">
            <summary>
            Returns a string containing the http headers
            </summary>
            <returns>
            Returns a string containing http headers with a status line but no trailing CRLF
            </returns>
        </member>
        <member name="M:Fiddler.HTTPResponseHeaders.AssignFromString(System.String)">
            <summary>
            Parses a string and assigns the headers parsed to this object
            </summary>
            <param name="sHeaders">The header string</param>
            <returns>TRUE if the operation succeeded, false otherwise</returns>
        </member>
        <member name="P:Fiddler.HTTPResponseHeaders.StatusDescription">
            <summary>
            Gets or sets the text associated with the response code (e.g. "OK", "Not Found", etc)
            </summary>
        </member>
        <member name="T:Fiddler.HTTPRequestHeaders">
            <summary>
            HTTP Request headers object
            </summary>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.GetEnumerator">
            <summary>
            Warning: You should protect your enumeration using the GetReaderLock
            </summary>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Warning: You should protect your enumeration using the GetReaderLock
            </summary>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.Clone">
            <summary>
            Clones the HTTP request headers 
            </summary>
            <returns>The new HTTPRequestHeaders object, cast to an object</returns>
        </member>
        <member name="F:Fiddler.HTTPRequestHeaders.HTTPMethod">
            <summary>
            The HTTP Method (e.g. GET, POST, etc)
            </summary>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.#ctor">
            <summary>
            Constructor for HTTP Request headers object
            </summary>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.#ctor(System.Text.Encoding)">
            <summary>
            Constructor for HTTP Request headers object
            </summary>
            <param name="encodingForHeaders">Text encoding to be used for this set of Headers when converting to a byte array</param>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.AssignFromString(System.String)">
            <summary>
            Parses a string and assigns the headers parsed to this object
            </summary>
            <param name="sHeaders">The header string</param>
            <returns>TRUE if the operation succeeded, false otherwise</returns>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.ToByteArray(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a byte array representing the HTTP headers.
            </summary>
            <param name="prependVerbLine">TRUE if the HTTP REQUEST line (method+path+httpversion) should be included</param>
            <param name="appendEmptyLine">TRUE if there should be a trailing \r\n byte sequence included</param>
            <param name="includeProtocolInPath">TRUE if the SCHEME and HOST should be included in the HTTP REQUEST LINE</param>
            <returns>The HTTP headers as a byte[]</returns>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.ToByteArray(System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Returns a byte array representing the HTTP headers.
            </summary>
            <param name="prependVerbLine">TRUE if the HTTP REQUEST line (method+path+httpversion) should be included</param>
            <param name="appendEmptyLine">TRUE if there should be a trailing \r\n byte sequence included</param>
            <param name="includeProtocolInPath">TRUE if the SCHEME and HOST should be included in the HTTP REQUEST LINE</param>
            <param name="sVerbLineHostOverride">Only meaningful if prependVerbLine is TRUE, the host to use in the HTTP REQUEST LINE</param>
            <returns>The HTTP headers as a byte[]</returns>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.ToString(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a string representing the HTTP headers.
            </summary>
            <param name="prependVerbLine">TRUE if the HTTP REQUEST line (method+path+httpversion) should be included</param>
            <param name="appendEmptyLine">TRUE if there should be a trailing CRLF sequence included</param>
            <param name="includeProtocolAndHostInPath">TRUE if the SCHEME and HOST should be included in the HTTP REQUEST LINE (Automatically set to FALSE for CONNECT requests)</param>
            <returns>The HTTP headers as a string.</returns>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a string representing the HTTP headers, without the SCHEME+HOST in the HTTP REQUEST line
            </summary>
            <param name="prependVerbLine">TRUE if the HTTP REQUEST line (method+path+httpversion) should be included</param>
            <param name="appendEmptyLine">TRUE if there should be a trailing CRLF sequence included</param>
            <returns>The header string</returns>
        </member>
        <member name="M:Fiddler.HTTPRequestHeaders.ToString">
            <summary>
            Returns a string representing the HTTP headers, without the SCHEME+HOST in the HTTP request line, and no trailing CRLF
            </summary>
            <returns>The header string</returns>
        </member>
        <member name="P:Fiddler.HTTPRequestHeaders.UriScheme">
            <summary>
            The (lowercased) URI scheme for this request (https, http, or ftp)
            </summary>
        </member>
        <member name="P:Fiddler.HTTPRequestHeaders.UriUserInfo">
            <summary>
            Username:Password info for FTP URLs. (either null or "user:pass@")
            (Note: It's silly that this contains a trailing @, but whatever...)
            </summary>
        </member>
        <member name="P:Fiddler.HTTPRequestHeaders.RequestPath">
            <summary>
            Get or set the request path as a string
            </summary>
        </member>
        <member name="P:Fiddler.HTTPRequestHeaders.RawPath">
            <summary>
            Get or set the request path as a byte array
            </summary>
        </member>
        <member name="T:Fiddler.HTTPHeaderItem">
            <summary>
            Represents a single HTTP header
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaderItem.Clone">
            <summary>
            Clones a single HTTP header and returns the clone cast to an object
            </summary>
            <returns>HTTPHeader Name: Value pair, cast to an object</returns>
        </member>
        <member name="F:Fiddler.HTTPHeaderItem.Name">
            <summary>
            The name of the HTTP header
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaderItem.Value">
            <summary>
            The value of the HTTP header
            </summary>
        </member>
        <member name="M:Fiddler.HTTPHeaderItem.#ctor(System.String,System.String)">
            <summary>
            Creates a new HTTP Header item. WARNING: Doesn't do any trimming or validation on the name.
            </summary>
            <param name="sName">Header name</param>
            <param name="sValue">Header value</param>
        </member>
        <member name="M:Fiddler.HTTPHeaderItem.ToString">
            <summary>
            Return a string of the form "NAME: VALUE"
            </summary>
            <returns>"NAME: VALUE" Header string</returns>
        </member>
        <member name="T:Fiddler.HTTPSUtilities">
            <summary>
            Provides simple utility functions common to both ClientHello and ServerHello parsing
            </summary>
        </member>
        <member name="M:Fiddler.HTTPSUtilities.GetExtensionString(System.Byte[])">
            <summary>
            Gets a textual string from a TLS extension
            </summary>
        </member>
        <member name="M:Fiddler.HTTPSUtilities.GetProtocolListAsString(System.Byte[])">
            <summary>
            Builds a string from an ALPN List of strings
            </summary>
        </member>
        <member name="M:Fiddler.HTTPSUtilities.GetSignatureAndHashAlgsAsString(System.Byte[])">
            <summary>
            List Sig/Hash pairs from  RFC5246
            </summary>
            <param name="arrData"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.HTTPSUtilities.GetECCCurvesAsString(System.Byte[])">
            <summary>
            List defined ECC Curves from RFC4492
            </summary>
            <param name="eccCurves"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.HTTPSUtilities.GetECCPointFormatsAsString(System.Byte[])">
            <summary>
            List defined ECC Point Formats from RFC4492
            </summary>
            <param name="eccPoints"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.HTTPSUtilities.HTTPSVersionToString(System.Int32,System.Int32)">
            <summary>
            Converts a HTTPS version to a "Major.Minor (Friendly)" string
            </summary>
        </member>
        <member name="T:Fiddler.HTTPSClientHello">
            <summary>
            The HTTPSClientHello class is used to parse the bytes of a HTTPS ClientHello message.
            </summary>
        </member>
        <member name="F:Fiddler.HTTPSClientHello.dictTLSCipherSuites">
            <summary>
            Map cipher id numbers to names. See http://www.iana.org/assignments/tls-parameters/
            Format is PROTOCOL_KEYAGREEMENT_AUTHENTICATIONMECHANISM_CIPHER_MACPRIMITIVE
            </summary>
        </member>
        <member name="M:Fiddler.HTTPSClientHello.ParseClientHelloExtension(System.Int32,System.Byte[])">
            <summary>
            Parse a single extension using the list from http://tools.ietf.org/html/rfc6066
            http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xml
            https://src.chromium.org/viewvc/chrome/trunk/src/net/third_party/nss/ssl/sslt.h
            </summary>
            <param name="iExtType"></param>
            <param name="arrData"></param>
        </member>
        <member name="M:Fiddler.HTTPSServerHello.ParseServerHelloExtension(System.Int32,System.Byte[])">
            <summary>
            Parse a single extension using the list from http://tools.ietf.org/html/rfc6066
            </summary>
            <param name="iExtType"></param>
            <param name="arrData"></param>
        </member>
        <member name="P:Fiddler.HTTPSServerHello.bALPNToSPDY">
            <summary>
            Did client use ALPN to go to SPDY?
            http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg-01#section-3.1
            </summary>
        </member>
        <member name="P:Fiddler.HTTPSServerHello.bNPNToSPDY">
            <summary>
             Did this ServerHello Handshake specify an upgrade to SPDY?
            </summary>
        </member>
        <member name="P:Fiddler.HTTPSServerHello.bALPNToHTTP2">
            <summary>
             Did this ServerHello Handshake specify an upgrade to SPDY?
            </summary>
        </member>
        <member name="T:Fiddler.Logger">
            <summary>
            The Logger object is a simple event log message dispatcher
            </summary>
        </member>
        <member name="F:Fiddler.Logger.queueStartupMessages">
            <summary>
            Queue of Messages that are be logged (usually during application startup) until another object has loaded and registered for notification of such Messages
            </summary>
        </member>
        <member name="M:Fiddler.Logger.#ctor(System.Boolean)">
            <summary>
            Creates a Logger object
            </summary>
            <param name="bQueueStartup">True if a queue should be created to store messages during Fiddler's startup</param>
        </member>
        <member name="M:Fiddler.Logger.FlushStartupMessages">
            <summary>
            Flushes previously-queued messages to the newly attached listener.
            </summary>
        </member>
        <member name="M:Fiddler.Logger.LogFormat(System.String,System.Object[])">
            <summary>
            Log a string with specified string formatting
            </summary>
            <param name="format">The format string</param>
            <param name="args">The arguments to replace in the string</param>
        </member>
        <member name="M:Fiddler.Logger.LogString(System.String)">
            <summary>
            Log a string
            </summary>
            <param name="sMsg">The string to log</param>
        </member>
        <member name="E:Fiddler.Logger.OnLogString">
            <summary>
            The Event to raise when a string is logged
            </summary>
        </member>
        <member name="T:Fiddler.LogEventArgs">
            <summary>
            EventArgs class for the LogEvent handler
            </summary>
        </member>
        <member name="P:Fiddler.LogEventArgs.LogString">
            <summary>
            The String which has been logged
            </summary>
        </member>
        <member name="T:Fiddler.MockTunnel">
            <summary>
            The MockTunnel represents a CONNECT tunnel which was reloaded from a SAZ file.
            </summary>
        </member>
        <member name="T:Fiddler.HTTPHeaderParseWarnings">
            <summary>
            Flags that indicate what problems, if any, were encountered in parsing HTTP headers
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaderParseWarnings.None">
            <summary>
            There were no problems parsing the HTTP headers
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaderParseWarnings.EndedWithLFLF">
            <summary>
            The HTTP headers ended incorrectly with \n\n
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaderParseWarnings.EndedWithLFCRLF">
            <summary>
            The HTTP headers ended incorrectly with \n\r\n
            </summary>
        </member>
        <member name="F:Fiddler.HTTPHeaderParseWarnings.Malformed">
            <summary>
            The HTTP headers were malformed.
            </summary>
        </member>
        <member name="T:Fiddler.Parser">
            <summary>
            The Parser class exposes static methods used to parse strings or byte arrays into HTTP messages.
            </summary>
        </member>
        <member name="M:Fiddler.Parser.CrackRequestLine(System.Byte[],System.Int32@,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Given a byte[] representing a request, determines the offsets of the components of the line. WARNING: Input MUST contain a LF or an exception will be thrown
            </summary>
            <param name="arrRequest">Byte array of the request</param>
            <param name="ixURIOffset">Returns the index of the byte of the URI in the Request line</param>
            <param name="iURILen">Returns the length of the URI in the Request line</param>
            <param name="ixHeaderNVPOffset">Returns the index of the first byte of the name/value header pairs</param>
        </member>
        <member name="M:Fiddler.Parser.FindEndOfHeaders(System.Byte[],System.Int32@,System.Int64,Fiddler.HTTPHeaderParseWarnings@)">
            <summary>
            
            </summary>
            <param name="arrData"></param>
            <param name="iBodySeekProgress">Index of final byte of headers, if found, or location that search should resume next time</param>
            <param name="lngDataLen"></param>
            <param name="oWarnings"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Parser.ParseNVPHeaders(Fiddler.HTTPHeaders,System.String[],System.Int32,System.String@)">
            <summary>
            Parse out HTTP Header lines.
            </summary>
            <param name="oHeaders">Header collection to *append* headers to</param>
            <param name="sHeaderLines">Array of Strings</param>
            <param name="iStartAt">Index into array at which parsing should start</param>
            <param name="sErrors">String containing any errors encountered</param>
            <returns>TRUE if there were no errors, false otherwise</returns>
        </member>
        <member name="M:Fiddler.Parser.FindEntityBodyOffsetFromArray(System.Byte[],System.Int32@,System.Int32@,Fiddler.HTTPHeaderParseWarnings@)">
            <summary>
            Given a byte array, determines the Headers length
            </summary>
            <param name="arrData">Input array of data</param>
            <param name="iHeadersLen">Returns the calculated length of the headers.</param>
            <param name="iEntityBodyOffset">Returns the calculated start of the response body.</param>
            <param name="outWarnings">Any HTTPHeaderParseWarnings discovered during parsing.</param>
            <returns>True, if the parsing was successful.</returns>
        </member>
        <member name="M:Fiddler.Parser.TakeRequest(System.IO.MemoryStream,Fiddler.HTTPRequestHeaders@,System.Byte[]@)">
            <summary>
            Given a MemoryStream, attempts to parse a HTTP Request starting at the current position.
            </summary>
            <returns>TRUE if a request could be parsed, FALSE otherwise</returns>
        </member>
        <member name="M:Fiddler.Parser.TakeResponse(System.IO.MemoryStream,System.String,Fiddler.HTTPResponseHeaders@,System.Byte[]@)">
            <summary>
            Given a MemoryStream, attempts to parse a HTTP Response starting at the current position
            </summary>
            <param name="bBodyForbidden">TRUE if the response must not have a body (e.g. because Request method was HEAD)</param>
            <returns>TRUE if a response could be parsed, FALSE otherwise</returns>
        </member>
        <member name="M:Fiddler.Parser.ParseRequest(System.String)">
            <summary>
            Parse the HTTP Request into a headers object.
            </summary>
            <param name="sRequest">The HTTP Request string, including *at least the headers* with a trailing CRLFCRLF</param>
            <returns>HTTPRequestHeaders parsed from the string.</returns>
        </member>
        <member name="M:Fiddler.Parser._GetHeaderLines(System.String)">
            <summary>
            Break headers off, then convert CRLFs into LFs
            </summary>
            <param name="sInput"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Parser.ParseResponse(System.String)">
            <summary>
            Parse the HTTP Response into a headers object.
            </summary>
            <param name="sResponse">The HTTP response as a string, including at least the headers.</param>
            <returns>HTTPResponseHeaders parsed from the string.</returns>
        </member>
        <member name="T:Fiddler.ChunkReader">
            <summary>
            Class allows finding the end of a body sent using Transfer-Encoding: Chunked
            </summary>
        </member>
        <member name="M:Fiddler.ChunkReader.getEntityLength">
            <summary>
            Number of bytes in the body (sans chunk headers, CRLFs, and trailers)
            </summary>
            <returns></returns>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.ReadStartOfSize">
            <summary>
            Read the first character of the hexadecimal size
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.ReadStartOfTrailer">
            <summary>
            Read the first character of the next Trailer header (if any)
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.ReadToTrailerCR">
            <summary>
            We're in a trailer. Read up to the next \r
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.ReadTrailerLF">
            <summary>
            We've just read a trailer CR, now read its LF
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.ReadFinalLF">
            <summary>
            We read a CR on an "empty" Trailer line, so now we just need the final LF
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.Completed">
            <summary>
            The chunked body was successfully read with no excess
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.Overread">
            <summary>
            Completed, but we read too many bytes. Call getOverage to return how many bytes to put back
            </summary>
        </member>
        <member name="F:Fiddler.ChunkedTransferState.Malformed">
            <summary>
            The body was malformed
            </summary>
        </member>
        <member name="T:Fiddler.PeriodicWorker">
             <summary>
             Somewhat similar to the Framework's "BackgroundWorker" class, the periodic worker performs a similar function on a periodic schedule.
             NOTE: the callback occurs on a background thread.
            
             The PeriodicWorker class is used by Fiddler to perform "cleanup" style tasks on a timer. Put work in the queue, 
             and it will see that it's done at least as often as the schedule specified until Fiddler begins to close at which
             point all work stops.
             
             
             The underlying timer's interval is 1 second.
             
             </summary>
             <remarks>
             I think a significant part of the reason that this class exists is that I thought the System.Threading.Timer consumed one thread for each
             timer. In reality, per "CLR via C# 4e" all of the instances share one underlying thread and thus my concern was misplaced. Ah well.
             </remarks>
        </member>
        <member name="M:Fiddler.PeriodicWorker.assignWork(Fiddler.SimpleEventHandler,System.UInt32)">
            <summary>
            Assigns a "job" to the Periodic worker, on the schedule specified by iMS. 
            </summary>
            <param name="workFunction">The function to run on the timer specified.
            Warning: the function is NOT called on the UI thread, so use .Invoke() if needed.</param>
            <param name="iMS">The # of milliseconds to wait between runs</param>
            <returns>A taskItem which can be used to revokeWork later</returns>
        </member>
        <member name="M:Fiddler.PeriodicWorker.revokeWork(Fiddler.PeriodicWorker.taskItem)">
            <summary>
            Revokes a previously-assigned task from this worker.
            </summary>
            <param name="oToRevoke"></param>
        </member>
        <member name="T:Fiddler.ScheduledTasks">
            <summary>
            The ScheduledTasks class allows addition of jobs by name. It ensures that ONE instance of the named
            job will occur at *some* point in the future, between 0 and a specified max delay. If you queue multiple
            instances of the same-named Task, it's only done once.
            </summary>
        </member>
        <member name="M:Fiddler.ScheduledTasks.doWork(System.Object)">
            <summary>
            Under the lock, we enumerate the schedule to find work to do and remove that work from the schedule.
            After we release the lock, we then do the queued work.
            </summary>
            <param name="objState"></param>
        </member>
        <member name="T:Fiddler.ScheduledTasks.jobItem">
            <summary>
            A jobItem represents a Function+Time tuple. The function will run after the given time.
            </summary>
        </member>
        <member name="F:Fiddler.ScheduledTasks.jobItem._ulRunAfter">
            <summary>
            TickCount at which this job must run.
            </summary>
        </member>
        <member name="F:Fiddler.ScheduledTasks.jobItem._oJob">
            <summary>
            Method to invoke to complete the job
            </summary>
        </member>
        <member name="T:Fiddler.BasePipe">
            <summary>
            Abstract base class for the ClientPipe and ServerPipe classes. A Pipe represents a connection to either the client or the server, optionally encrypted using SSL/TLS.
            </summary>
        </member>
        <member name="F:Fiddler.BasePipe._baseSocket">
            <summary>
            The base socket wrapped in this pipe
            </summary>
        </member>
        <member name="F:Fiddler.BasePipe.iUseCount">
            <summary>
            The number of times that this Pipe has been used
            </summary>
        </member>
        <member name="F:Fiddler.BasePipe._httpsStream">
            <summary>
            The HTTPS stream wrapped around the base socket
            </summary>
        </member>
        <member name="F:Fiddler.BasePipe._sPipeName">
            <summary>
            The display name of this Pipe
            </summary>
        </member>
        <member name="F:Fiddler.BasePipe._iTransmitDelayMS">
            <summary>
            Number of milliseconds to delay each 1024 bytes transmitted
            </summary>
        </member>
        <member name="M:Fiddler.BasePipe.#ctor(System.Net.Sockets.Socket,System.String)">
            <summary>
            Create a new pipe, an enhanced wrapper around a socket
            </summary>
            <param name="oSocket">Socket which this pipe wraps</param>
            <param name="sName">Identification string used for debugging purposes</param>
        </member>
        <member name="M:Fiddler.BasePipe.HasDataAvailable">
            <summary>
            Poll the underlying socket for readable data (or closure/errors)
            </summary>
            <returns>TRUE if this Pipe requires attention</returns>
        </member>
        <member name="M:Fiddler.BasePipe.IncrementUse(System.Int32)">
            <summary>
            Call this method when about to reuse a socket. Currently, increments the socket's UseCount and resets its transmit delay to 0.
            </summary>
            <param name="iSession">The session identifier of the new session, or zero</param>
        </member>
        <member name="M:Fiddler.BasePipe.Send(System.Byte[])">
            <summary>
            Sends a byte array through this pipe
            </summary>
            <param name="oBytes">The bytes</param>
        </member>
        <member name="M:Fiddler.BasePipe.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends the data specified in oBytes (between iOffset and iOffset+iCount-1 inclusive) down the pipe.
            </summary>
            <param name="oBytes"></param>
            <param name="iOffset"></param>
            <param name="iCount"></param>
        </member>
        <member name="M:Fiddler.BasePipe.Receive(System.Byte[])">
            <summary>
            Receive bytes from the pipe into the DATA buffer.
            </summary>
            <exception cref="T:System.IO.IOException">Throws IO exceptions from the socket/stream</exception>
            <param name="arrBuffer">Array of data read</param>
            <returns>Bytes read</returns>
        </member>
        <member name="M:Fiddler.BasePipe.GetRawSocket">
            <summary>
            Return the raw socket this pipe wraps. Avoid calling this method if at all possible.
            </summary>
            <returns>The Socket object this Pipe wraps.</returns>
        </member>
        <member name="M:Fiddler.BasePipe.End">
            <summary>
            Shutdown and close the socket inside this pipe. Eats exceptions.
            </summary>
        </member>
        <member name="M:Fiddler.BasePipe.EndWithRST">
            <summary>
            Abruptly closes the socket by sending a RST packet
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.Connected">
            <summary>
            Return the Connected status of the base socket. 
            WARNING: This doesn't work as you might expect; you can see Connected == false when a READ timed out but a WRITE will succeed.
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.bIsSecured">
            <summary>
            Returns a bool indicating if the socket in this Pipe is CURRENTLY connected and wrapped in a SecureStream
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.SecureProtocol">
            <summary>
            Returns the SSL/TLS protocol securing this connection
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.Port">
            <summary>
            Return the Remote Port to which this socket is attached.
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.LocalPort">
            <summary>
            Return the Local Port to which the base socket is attached. Note: May return a misleading port if the ISA Firewall Client is in use.
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.Address">
            <summary>
            Returns the remote address to which this Pipe is connected, or 0.0.0.0 on error.
            </summary>
        </member>
        <member name="P:Fiddler.BasePipe.TransmitDelay">
            <summary>
            Gets or sets the transmission delay on this Pipe, used for performance simulation purposes.
            </summary>
        </member>
        <member name="T:Fiddler.ClientPipe">
            <summary>
            A ClientPipe wraps a socket connection to a client application.
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._ProcessLookupSkipsLoopbackCheck">
            <summary>
            By default, we now test for loopbackness before lookup of PID
            https://github.com/telerik/fiddler/issues/83
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._timeoutFirstReceive">
            <summary>
            Timeout to wait for the *first* data from the client
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._timeoutReceiveLoop">
            <summary>
            Timeout to wait for the ongoing reads from the client (as headers and body are read)
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._timeoutIdle">
            <summary>
            Timeout before which an idle connection is closed (e.g. for HTTP Keep-Alive)
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._sProcessName">
            <summary>
            Client process name (e.g. "iexplore")
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._iProcessID">
            <summary>
            Client process ProcessID
            </summary>
        </member>
        <member name="F:Fiddler.ClientPipe._arrReceivedAndPutBack">
            <summary>
            Data which was previously "over-read" from the client. Populated when HTTP-pipelining is attempted
            </summary>
        </member>
        <member name="M:Fiddler.ClientPipe.HasDataAvailable">
            <summary>
            Does this Pipe have data (or closure/errors) to read?
            </summary>
            <returns>TRUE if this Pipe requires attention</returns>
        </member>
        <member name="M:Fiddler.ClientPipe.putBackSomeBytes(System.Byte[])">
            <summary>
            If you previously read more bytes than you needed from this client socket, you can put some back.
            </summary>
            <param name="toPutback">Array of bytes to put back; now owned by this object</param>
        </member>
        <member name="M:Fiddler.ClientPipe.setReceiveTimeout(System.Boolean)">
            <summary>
            Sets the socket's timeout based on whether we're waiting for our first read or for an ongoing read-loop
            </summary>
        </member>
        <member name="M:Fiddler.ClientPipe.ToString">
            <summary>
            Returns a semicolon-delimited string describing this ClientPipe
            </summary>
            <returns>A semicolon-delimited string</returns>
        </member>
        <member name="M:Fiddler.ClientPipe.SecureClientPipeDirect(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Perform a HTTPS Server handshake to the client. Swallows exception and returns false on failure.
            </summary>
            <param name="certServer"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ClientPipe.SecureClientPipe(System.String,Fiddler.HTTPResponseHeaders)">
            <summary>
            This function sends the client socket a CONNECT ESTABLISHED, and then performs a HTTPS authentication
            handshake, with Fiddler acting as the server.
            </summary>
            <param name="sHostname">Hostname Fiddler is pretending to be (NO PORT!)</param>
            <param name="oHeaders">The set of headers to be returned to the client in response to the client's CONNECT tunneling request</param>
            <returns>true if the handshake succeeds</returns>
        </member>
        <member name="P:Fiddler.ClientPipe.LocalProcessID">
            <summary>
            ID of the process that opened this socket, assuming that Port Mapping is enabled, and the connection is from the local machine
            </summary>
        </member>
        <member name="P:Fiddler.ClientPipe.LocalProcessName">
            <summary>
            Name of the Process referred to by LocalProcessID, or String.Empty if unknown
            </summary>
        </member>
        <member name="P:Fiddler.ClientPipe.dtAccepted">
            <summary>
            Timestamp of either 1> The underlying socket's creation from a .Accept() call, or 2> when this ClientPipe was created.
            </summary>
        </member>
        <member name="T:Fiddler.PipePool">
            <summary>
            The PipePool maintains a collection of connected ServerPipes for reuse
            </summary>
        </member>
        <member name="F:Fiddler.PipePool.MSEC_PIPE_POOLED_LIFETIME">
            <summary>
            Minimum idle time of pipes to be expired from the pool.
            Note, we don't check the pipe's ulLastPooled value when extracting a pipe, 
            so its age could exceed the allowed lifetime by up to MSEC_POOL_CLEANUP_INTERVAL
            WARNING: Don't change the timeout >2 minutes casually. Server bugs apparently exist: https://bugzilla.mozilla.org/show_bug.cgi?id=491541
            </summary>
        </member>
        <member name="F:Fiddler.PipePool.thePool">
            <summary>
            The Pool itself.
            </summary>
        </member>
        <member name="F:Fiddler.PipePool.lngLastPoolPurge">
            <summary>
            Time at which a "Clear before" operation was conducted. We store this
            so that we don't accidentally put any pipes that were in use back into
            the pool after a clear operation
            </summary>
        </member>
        <member name="M:Fiddler.PipePool.ScavengeCache">
            <summary>
            Remove any pipes from Stacks if they exceed the age threshold
            Remove any Stacks from pool if they are empty
            </summary>
        </member>
        <member name="M:Fiddler.PipePool.Clear">
            <summary>
            Clear all pooled Pipes, calling .End() on each.
            </summary>
        </member>
        <member name="M:Fiddler.PipePool.InspectPool">
            <summary>
            Return a string representing the Pipes in the Pool
            </summary>
            <returns>A string representing the pipes in the pool</returns>
        </member>
        <member name="M:Fiddler.PipePool.TakePipe(System.String,System.Int32,System.Int32)">
            <summary>
            Get a Server connection for reuse, or null if a suitable connection is not in the pool.
            </summary>
            <param name="sPoolKey">The key which identifies the connection to search for.</param>
            <param name="iPID">The ProcessID of the client requesting the Pipe</param>
            <param name="HackiForSession">HACK to be removed; the SessionID# of the request for logging</param>
            <returns>A Pipe to reuse, or NULL</returns>
        </member>
        <member name="M:Fiddler.PipePool.PoolOrClosePipe(Fiddler.ServerPipe)">
            <summary>
            Store a pipe for later use, if reuse is allowed by settings and state of the pipe.
            </summary>
            <param name="oPipe">The Pipe to place in the pool</param>
        </member>
        <member name="T:Fiddler.PipeReadBuffer">
             <summary>
             This class holds a specialized memory stream with growth characteristics more suitable for reading from a HTTP Stream.
             The default MemoryStream's Capacity will always grow to 256 bytes, then at least ~2x current capacity up to 1gb (2gb on .NET 4.6), then to the exact length after that.
             That has three problems:
            
                 The capacity may unnecessarily grow to >85kb, putting the object on the LargeObjectHeap even if we didn't really need 85kb.
                 On 32bit, we may hit a Address Space exhaustion ("Out of memory" exception) prematurely and unnecessarily due to size-doubling
                 After the capacity reaches 1gb in length, the capacity growth never exceeds the length, leading to huge reallocations and copies on every write (fixed in .NET 4.6)
            
             This class addresses those issues. http://textslashplain.com/2015/08/06/tuning-memorystream/
             </summary>
        </member>
        <member name="F:Fiddler.PipeReadBuffer._HintedSize">
            <summary>
            A client may submit a "hint" of the expected size. We use that if present.
            </summary>
        </member>
        <member name="M:Fiddler.PipeReadBuffer.HintTotalSize(System.UInt32)">
            <summary>
            Used by the caller to supply a hint on the expected total size of reads from the pipe.
            We cannot blindly trust this value because sometimes the client or server will lie and provide a
            huge value that it will never use. This is common for RPC-over-HTTPS tunnels like that used by 
            Outlook, for instance.
            
            The Content-Length can also lie by underreporting the size.
            </summary>
            <param name="iHint">Suggested total buffer size in bytes</param>
        </member>
        <member name="T:Fiddler.PipeReusePolicy">
            <summary>
            The policy which describes how this pipe may be reused by a later request. Ordered by least restrictive to most.
            </summary>
        </member>
        <member name="F:Fiddler.PipeReusePolicy.NoRestrictions">
            <summary>
            The ServerPipe may be freely reused by any subsequent request
            </summary>
        </member>
        <member name="F:Fiddler.PipeReusePolicy.MarriedToClientProcess">
            <summary>
            The ServerPipe may be reused only by a subsequent request from the same client process
            </summary>
        </member>
        <member name="F:Fiddler.PipeReusePolicy.MarriedToClientPipe">
            <summary>
            The ServerPipe may be reused only by a subsequent request from the same client pipe
            </summary>
        </member>
        <member name="F:Fiddler.PipeReusePolicy.NoReuse">
            <summary>
            The ServerPipe may not be reused for a subsequent request
            </summary>
        </member>
        <member name="T:Fiddler.ServerPipe">
            <summary>
            A ServerPipe wraps a socket connection to a server.
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe.dtConnected">
            <summary>
            DateTime of the completion of the TCP/IP Connection
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe.ulLastPooled">
            <summary>
            TickCount when this Pipe was last placed in a PipePool
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._bIsConnectedToGateway">
            <summary>
            Returns TRUE if this ServerPipe is connected to a Gateway
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._bIsConnectedViaSOCKS">
            <summary>
            Returns TRUE if this ServerPipe is connected to a SOCKS gateway
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._sPoolKey">
            <summary>
            The Pooling key used for reusing a previously pooled ServerPipe. See sPoolKey property.
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._iMarriedToPID">
            <summary>
            This field, if set, tracks the process ID to which this Pipe is permanently bound; set by MarkAsAuthenticated.
            NOTE: This isn't actually checked by anyone; instead the PID is added to the POOL Key
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._isAuthenticated">
            <summary>
            Backing field for the isAuthenticated property
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._ServerCertChain">
            <summary>
            String containing representation of the server's certificate chain
            </summary>
        </member>
        <member name="F:Fiddler.ServerPipe._certServer">
            <summary>
            Server's certificate
            </summary>
        </member>
        <member name="M:Fiddler.ServerPipe.#ctor(System.Net.Sockets.Socket,System.String,System.Boolean,System.String)">
            <summary>
            Wraps a socket in a Pipe
            </summary>
            <param name="oSocket">The Socket</param>
            <param name="sName">Pipe's human-readable name</param>
            <param name="bConnectedToGateway">True if the Pipe is attached to a gateway</param>
            <param name="sPoolingKey">The Pooling key used for socket reuse</param>
        </member>
        <member name="M:Fiddler.ServerPipe.MarkAsAuthenticated(System.Int32)">
            <summary>
            Marks this Pipe as having been authenticated. Depending on the preference "fiddler.network.auth.reusemode" this may impact the reuse policy for this pipe
            </summary>
            <param name="clientPID">The client's process ID, if known.</param>
        </member>
        <member name="M:Fiddler.ServerPipe.setTimeouts">
            <summary>
            Sets the receiveTimeout based on whether this is a freshly opened server socket or a reused one.
            </summary>
        </member>
        <member name="M:Fiddler.ServerPipe.ToString">
            <summary>
            Returns a semicolon-delimited string describing this ServerPipe
            </summary>
            <returns>A semicolon-delimited string</returns>
        </member>
        <member name="M:Fiddler.ServerPipe.GetServerCertCN">
            <summary>
            Returns the Server's certificate Subject CN (used by "x-UseCertCNFromServer")
            </summary>
            <returns>The *FIRST* CN field from the Subject of the certificate used to secure this HTTPS connection, or null if the connection is unsecure</returns>
        </member>
        <member name="M:Fiddler.ServerPipe.DescribeConnectionSecurity">
            <summary>
            Return a string describing the HTTPS connection security, if this socket is secured
            </summary>
            <returns>A string describing the HTTPS connection's security.</returns>
        </member>
        <member name="M:Fiddler.ServerPipe.GetConnectionCipherInfo">
            <summary>
            Returns a string describing how this connection is secured.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ServerPipe._GetTransportContext">
            <summary>
            Get the Transport Context for the underlying HTTPS connection so that Channel-Binding Tokens work correctly
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ServerPipe._GetDefaultCertificate">
            <summary>
            Get the user's default client cert for authentication; caching if if possible and permitted.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ServerPipe.AttachClientCertificate(Fiddler.Session,System.Object,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String[])">
            <summary>
            This method is called by the HTTPS Connection establishment to optionally attach a client certificate to the request.
            Test Page: https://tower.dartmouth.edu/doip/OracleDatabases.jspx or ClientCertificate.ms in Test folder should request on initial connection
            In contrast, this one: https://roaming.officeapps.live.com/rs/roamingsoapservice.svc appears to try twice (renego)
            </summary>
            <param name="sender"></param>
            <param name="targetHost"></param>
            <param name="localCertificates"></param>
            <param name="remoteCertificate"></param>
            <param name="acceptableIssuers"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ServerPipe.SecureExistingConnection(Fiddler.Session,System.String,System.String,System.Security.Authentication.SslProtocols,System.Int32@)">
            <summary>
            This function secures an existing connection and authenticates as client. This is primarily useful when
            the socket is connected to a Gateway/Proxy and we had to send a CONNECT and get a HTTP/200 Connected back before
            we actually secure the socket.
             http://msdn.microsoft.com/en-us/library/system.net.security.sslstream.aspx
            </summary>
            <param name="oS">The Session (a CONNECT) this tunnel wraps</param>
            <param name="sCertCN">The CN to use in the certificate</param>
            <param name="sClientCertificateFilename">Path to client certificate file</param>
            <param name="sslprotClient">The HTTPS protocol version of the Client Pipe; can influence which SslProtocols we offer the server</param>
            <param name="iHandshakeTime">Reference-passed integer which returns the time spent securing the connection</param>
            <returns>TRUE if the connection can be secued</returns>
        </member>
        <member name="M:Fiddler.ServerPipe.GetCertificateCollectionFromFile(System.String)">
            <summary>
            Return a Certificate Collection containing certificate from the specified file. 
            </summary>
            <param name="sClientCertificateFilename">Path to the certificate. Relative Paths will be absolutified automatically</param>
            <returns>The Certificate collection, or null</returns>
        </member>
        <member name="P:Fiddler.ServerPipe.ReusePolicy">
            <summary>
            Policy for reuse of this pipe
            </summary>
        </member>
        <member name="P:Fiddler.ServerPipe.isClientCertAttached">
            <summary>
            Returns TRUE if there is an underlying, mutually-authenticated HTTPS stream.
            
            WARNING: Results are a bit of a lie. System.NET IsMutuallyAuthenticated == true if a client certificate is AVAILABLE even
            if that certificate was never SENT to the server.
            </summary>
        </member>
        <member name="P:Fiddler.ServerPipe.isAuthenticated">
            <summary>
            Returns TRUE if this PIPE is marked as having been authenticated using a Connection-Oriented Auth protocol:
            NTLM, Kerberos, or HTTPS Client Certificate.
            </summary>
        </member>
        <member name="P:Fiddler.ServerPipe.isConnectedToGateway">
            <summary>
            Indicates if this pipe is connected to an upstream (non-SOCKS) Proxy.
            </summary>
        </member>
        <member name="P:Fiddler.ServerPipe.isConnectedViaSOCKS">
            <summary>
            Indicates if this pipe is connected to a SOCKS gateway
            </summary>
        </member>
        <member name="P:Fiddler.ServerPipe.sPoolKey">
            <summary>
            Gets and sets the pooling key for this server pipe.
            </summary>
            <example>
              direct->{http|https}/{serverhostname}:{serverport}
              gw:{gatewayaddr:port}->*
              gw:{gatewayaddr:port}->{http|https}/{serverhostname}:{serverport}
              socks:{gatewayaddr:port}->{http|https}/{serverhostname}:{serverport}
            </example>
        </member>
        <member name="P:Fiddler.ServerPipe.RemoteEndPoint">
            <summary>
            Returns the IPEndPoint to which this socket is connected, or null
            </summary>
        </member>
        <member name="T:Fiddler.PrefChangeEventArgs">
            <summary>
            EventArgs for preference-change events.  See http://msdn.microsoft.com/en-us/library/ms229011.aspx.
            </summary>
        </member>
        <member name="P:Fiddler.PrefChangeEventArgs.PrefName">
            <summary>
            The name of the preference being added, changed, or removed
            </summary>
        </member>
        <member name="P:Fiddler.PrefChangeEventArgs.ValueString">
            <summary>
            The string value of the preference, or null if the preference is being removed
            </summary>
        </member>
        <member name="P:Fiddler.PrefChangeEventArgs.ValueBool">
            <summary>
            Returns TRUE if ValueString=="true", case-insensitively
            </summary>
        </member>
        <member name="T:Fiddler.IFiddlerPreferences">
            <summary>
            The IFiddlerPreferences Interface is exposed by the FiddlerApplication.Prefs object, and enables
            callers to Add, Update, and Remove preferences, as well as observe changes to the preferences.
            </summary>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.SetBoolPref(System.String,System.Boolean)">
            <summary>
            Store a boolean value for a preference
            </summary>
            <param name="sPrefName">The named preference</param>
            <param name="bValue">The boolean value to store</param>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.SetInt32Pref(System.String,System.Int32)">
            <summary>
            Store an Int32 value for a preference
            </summary>
            <param name="sPrefName">The named preference</param>
            <param name="iValue">The int32 value to store</param>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.SetStringPref(System.String,System.String)">
            <summary>
            Store a string value for a preference
            </summary>
            <param name="sPrefName">The named preference</param>
            <param name="sValue">The string value to store</param>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.GetBoolPref(System.String,System.Boolean)">
            <summary>
            Get a preference's value as a boolean
            </summary>
            <param name="sPrefName">The Preference Name</param>
            <param name="bDefault">The default value for missing or invalid preferences</param>
            <returns>A Boolean</returns>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.GetStringPref(System.String,System.String)">
            <summary>
            Gets a preference's value as a string
            </summary>
            <param name="sPrefName">The Preference Name</param>
            <param name="sDefault">The default value for missing preferences</param>
            <returns>A string</returns>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.GetInt32Pref(System.String,System.Int32)">
            <summary>
            Gets a preference's value as a 32-bit integer
            </summary>
            <param name="sPrefName">The Preference Name</param>
            <param name="iDefault">The default value for missing or invalid preferences</param>
            <returns>An integer</returns>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.RemovePref(System.String)">
            <summary>
            Removes a named preference from storage
            </summary>
            <param name="sPrefName">The name of the preference to remove</param>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.AddWatcher(System.String,System.EventHandler{Fiddler.PrefChangeEventArgs})">
            <summary>
            Add a Watcher that will be notified when a value has changed within the specified prefix.
            </summary>
            <param name="sPrefixFilter">The prefix of preferences for which changes are interesting</param>
            <param name="pcehHandler">The Event handler to notify</param>
            <returns>Returns the Watcher object added to the notification list</returns>
        </member>
        <member name="M:Fiddler.IFiddlerPreferences.RemoveWatcher(Fiddler.PreferenceBag.PrefWatcher)">
            <summary>
            Removes a previously-created preference Watcher from the notification queue
            </summary>
            <param name="wliToRemove">The Watcher to remove</param>
        </member>
        <member name="P:Fiddler.IFiddlerPreferences.Item(System.String)">
            <summary>
            Indexer. Returns the value of the preference as a string
            </summary>
            <param name="sName">The Preference Name</param>
            <returns>The Preference value as a string, or null</returns>
        </member>
        <member name="T:Fiddler.PreferenceBag">
            <summary>
            The PreferenceBag is used to maintain a threadsafe Key/Value list of preferences, persisted in the registry, and with appropriate eventing when a value changes.
            </summary>
        </member>
        <member name="M:Fiddler.PreferenceBag.ReadRegistry">
            <summary>
            Load the existing preferences from the Registry into the Preferences bag.
            Note: Does not fire any events.
            </summary>
        </member>
        <member name="M:Fiddler.PreferenceBag.WriteRegistry">
            <summary>
            Serialize the existing preferences to the Registry (unless in Viewer mode).
            </summary>
        </member>
        <member name="M:Fiddler.PreferenceBag.GetPrefArray">
            <summary>
            Get a string array of the preference names
            </summary>
            <returns>string[] of preference names</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.GetStringPref(System.String,System.String)">
            <summary>
            Gets a preference's value as a string
            </summary>
            <param name="sPrefName">The Preference Name</param>
            <param name="sDefault">The default value if the preference is missing</param>
            <returns>A string</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.GetBoolPref(System.String,System.Boolean)">
            <summary>
            Return a bool preference.
            </summary>
            <param name="sPrefName">The Preference name</param>
            <param name="bDefault">The default value to return if the specified preference does not exist</param>
            <returns>The boolean value of the Preference, or the default value</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.GetInt32Pref(System.String,System.Int32)">
            <summary>
            Return an Int32 Preference.
            </summary>
            <param name="sPrefName">The Preference name</param>
            <param name="iDefault">The default value to return if the specified preference does not exist</param>
            <returns>The Int32 value of the Preference, or the default value</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.SetStringPref(System.String,System.String)">
            <summary>
            Update or create a string preference.
            </summary>
            <param name="sPrefName">The name of the Preference</param>
            <param name="sValue">The value to assign to the Preference</param>
        </member>
        <member name="M:Fiddler.PreferenceBag.SetInt32Pref(System.String,System.Int32)">
            <summary>
            Update or create a Int32 Preference
            </summary>
            <param name="sPrefName">The name of the Preference</param>
            <param name="iValue">The value to assign to the Preference</param>
        </member>
        <member name="M:Fiddler.PreferenceBag.SetBoolPref(System.String,System.Boolean)">
            <summary>
            Update or create a Boolean preference.
            </summary>
            <param name="sPrefName">The name of the Preference</param>
            <param name="bValue">The value to assign to the Preference</param>
        </member>
        <member name="M:Fiddler.PreferenceBag.RemovePref(System.String)">
            <summary>
            Delete a Preference from the collection.
            </summary>
            <param name="sPrefName">The name of the Preference to be removed.</param>
        </member>
        <member name="M:Fiddler.PreferenceBag._clearWatchers">
            <summary>
            Remove all Watchers
            </summary>
        </member>
        <member name="M:Fiddler.PreferenceBag.Close">
            <summary>
            Remove all watchers and write the registry.
            </summary>
        </member>
        <member name="M:Fiddler.PreferenceBag.ToString">
            <summary>
            Return a description of the contents of the preference bag
            </summary>
            <returns>Multi-line string</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.ToString(System.Boolean)">
            <summary>
            Return a string-based serialization of the Preferences settings.
            </summary>
            <param name="bVerbose">TRUE for a multi-line format with all preferences</param>
            <returns>String</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.FindMatches(System.String)">
            <summary>
            Returns a CRLF-delimited string containing all Preferences whose Name case-insensitively contains the specified filter string.
            </summary>
            <param name="sFilter">Partial string to match</param>
            <returns>A string</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.AddWatcher(System.String,System.EventHandler{Fiddler.PrefChangeEventArgs})">
            <summary>
            Add a watcher for changes to the specified preference or preference branch.
            </summary>
            <param name="sPrefixFilter">Preference branch to monitor, or String.Empty to watch all</param>
            <param name="pcehHandler">The EventHandler accepting PrefChangeEventArgs to notify</param>
            <returns>Returns the PrefWatcher object which has been added, store to pass to RemoveWatcher later.</returns>
        </member>
        <member name="M:Fiddler.PreferenceBag.RemoveWatcher(Fiddler.PreferenceBag.PrefWatcher)">
            <summary>
            Remove a previously attached Watcher
            </summary>
            <param name="wliToRemove">The previously-specified Watcher</param>
        </member>
        <member name="M:Fiddler.PreferenceBag._NotifyThreadExecute(System.Object)">
            <summary>
            This function executes on a single background thread and notifies any registered
            Watchers of changes in preferences they care about.
            </summary>
            <param name="objThreadState">A string containing the name of the Branch that changed</param>
        </member>
        <member name="M:Fiddler.PreferenceBag.AsyncNotifyWatchers(Fiddler.PrefChangeEventArgs)">
            <summary>
            Spawn a background thread to notify any interested Watchers of changes to the Target preference branch.
            </summary>
            <param name="oNotifyArgs">The arguments to pass to the interested Watchers</param>
        </member>
        <member name="P:Fiddler.PreferenceBag.CurrentProfile">
            <summary>
            Returns a string naming the current profile
            </summary>
        </member>
        <member name="P:Fiddler.PreferenceBag.Item(System.String)">
            <summary>
            Indexer into the Preference collection.
            </summary>
            <param name="sPrefName">The name of the Preference to update/create or return.</param>
            <returns>The string value of the preference, or null.</returns>
        </member>
        <member name="T:Fiddler.PreferenceBag.PrefWatcher">
            <summary>
            A simple struct which contains a Branch identifier and EventHandler
            </summary>
        </member>
        <member name="T:Fiddler.ProcessHelper">
            <summary>
            This class allows fast-lookup of a ProcessName from a ProcessID.
            </summary>
        </member>
        <member name="M:Fiddler.ProcessHelper.#cctor">
            <summary>
            Static constructor which registers for cleanup
            </summary>
        </member>
        <member name="M:Fiddler.ProcessHelper.ScavengeCache">
            <summary>
            Prune the cache of expiring PIDs
            </summary>
        </member>
        <member name="M:Fiddler.ProcessHelper.GetProcessName(System.Int32)">
            <summary>
            Map a Process ID (PID) to a Process Name
            </summary>
            <param name="iPID">The PID</param>
            <returns>A Process Name (e.g. IEXPLORE.EXE) or String.Empty</returns>
        </member>
        <member name="T:Fiddler.ProcessHelper.ProcessNameCacheEntry">
            <summary>
            Structure mapping a Process ID (PID) to a ProcessName
            </summary>
        </member>
        <member name="F:Fiddler.ProcessHelper.ProcessNameCacheEntry.ulLastLookup">
            <summary>
            The TickCount when this entry was created
            </summary>
        </member>
        <member name="F:Fiddler.ProcessHelper.ProcessNameCacheEntry.sProcessName">
            <summary>
            The ProcessName (e.g. IEXPLORE.EXE)
            </summary>
        </member>
        <member name="M:Fiddler.ProcessHelper.ProcessNameCacheEntry.#ctor(System.String)">
            <summary>
            Create a PID->ProcessName mapping
            </summary>
            <param name="_sProcessName">The ProcessName (e.g. IEXPLORE.EXE)</param>
        </member>
        <member name="T:Fiddler.Proxy">
            <summary>
            The core proxy object which accepts connections from clients and creates session objects from those connections
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.oRegistryWatcher">
            <summary>
            The RegistryWatcher is used to monitor changes in the WinINET Proxy registry keys
            to detect premature detaches.
            </summary>
        </member>
        <member name="F:Fiddler.Proxy._sHTTPSHostname">
            <summary>
            Hostname if this Proxy Endpoint is terminating HTTPS connections
            </summary>
        </member>
        <member name="F:Fiddler.Proxy._oHTTPSCertificate">
            <summary>
            Certificate if this Proxy Endpoint is terminating HTTPS connections
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.oAllConnectoids">
            <summary>
            Per-connectoid information about each WinINET connectoid
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.piSystemGateway">
            <summary>
            The default WinINET proxy as determined upon Fiddler startup.
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.oAutoProxy">
            <summary>
            The WinHTTP AutoProxy object, created if we're using WPAD or a PAC Script as a gateway
            </summary>
        </member>
        <member name="F:Fiddler.Proxy._DefaultEgressEndPoint">
            <summary>
            Allow binding to a specific egress adapter: "fiddler.network.egress.ip"
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.watcherPrefNotify">
            <summary>
            Watcher for Notification of Preference changes
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.htServerPipePool">
            <summary>
            Server connections may be pooled for performance reasons.
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.oAcceptor">
            <summary>
            The Socket Endpoint on which this proxy receives requests
            </summary>
        </member>
        <member name="F:Fiddler.Proxy._bDetaching">
            <summary>
            Flag indicating that Fiddler is in the process of detaching...
            </summary>
        </member>
        <member name="F:Fiddler.Proxy.oBypassList">
            <summary>
            List of hosts which should bypass the upstream gateway
            </summary>
        </member>
        <member name="M:Fiddler.Proxy.ToString">
            <summary>
            Returns a string of information about this instance and the ServerPipe reuse pool
            </summary>
            <returns>A multiline string</returns>
        </member>
        <member name="M:Fiddler.Proxy.SetDefaultEgressEndPoint(System.String)">
            <summary>
            Change the outbound IP address used to send traffic
            </summary>
            <param name="sEgressIP"></param>
        </member>
        <member name="M:Fiddler.Proxy.onNetworkPrefsChange(System.Object,Fiddler.PrefChangeEventArgs)">
            <summary>
            Watch for relevent changes on the Preferences object
            </summary>
            <param name="sender"></param>
            <param name="oPCE"></param>
        </member>
        <member name="M:Fiddler.Proxy.NetworkChange_NetworkAddressChanged(System.Object,System.EventArgs)">
            <summary>
            Called whenever Windows reports that the system's NetworkAddress has changed
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fiddler.Proxy.NetworkChange_NetworkAvailabilityChanged(System.Object,System.Net.NetworkInformation.NetworkAvailabilityEventArgs)">
            <summary>
            Called by Windows whenever network availability goes up or down.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fiddler.Proxy.SendRequest(System.String,System.Collections.Specialized.StringDictionary)">
            <summary>
            Directly inject a session into the Fiddler pipeline, returning a reference to it.
            NOTE: This method will THROW any exceptions to its caller.
            </summary>
            <param name="sRequest">String representing the HTTP request. If headers only, be sure to end with CRLFCRLF</param>
            <param name="oNewFlags">StringDictionary of Session Flags (or null)</param>
            <returns>The new session</returns>
        </member>
        <member name="M:Fiddler.Proxy.InjectCustomRequest(Fiddler.HTTPRequestHeaders,System.Byte[],System.Collections.Specialized.StringDictionary)">
            <summary>
            [DEPRECATED] Directly inject a session into the Fiddler pipeline.
            NOTE: This method will THROW any exceptions to its caller.
            </summary>
            <see cref="M:Fiddler.Proxy.SendRequest(Fiddler.HTTPRequestHeaders,System.Byte[],System.Collections.Specialized.StringDictionary)"/>
            <param name="oHeaders">HTTP Request Headers</param>
            <param name="arrRequestBodyBytes">HTTP Request body (or null)</param>
            <param name="oNewFlags">StringDictionary of Session Flags (or null)</param>
        </member>
        <member name="M:Fiddler.Proxy.InjectCustomRequest(System.String,System.Collections.Specialized.StringDictionary)">
            <summary>
            [DEPRECATED] Directly inject a session into the Fiddler pipeline.
            NOTE: This method will THROW any exceptions to its caller.
            </summary>
            <see cref="M:Fiddler.Proxy.SendRequest(System.String,System.Collections.Specialized.StringDictionary)"/>
            <param name="sRequest">String representing the HTTP request. If headers only, be sure to end with CRLFCRLF</param>
            <param name="oNewFlags">StringDictionary of Session Flags (or null)</param>
        </member>
        <member name="M:Fiddler.Proxy.InjectCustomRequest(System.String)">
            <summary>
            [DEPRECATED]: This version does no validation of the request data, and doesn't set SessionFlags.RequestGeneratedByFiddler
            Send a custom HTTP request to Fiddler's listening endpoint (127.0.0.1:8888 by default).
            NOTE: This method will THROW any exceptions to its caller and blocks the current thread.
            </summary>
            <see cref="M:Fiddler.Proxy.SendRequest(System.String,System.Collections.Specialized.StringDictionary)"/>
            <param name="sRequest">String representing the HTTP request. If headers only, be sure to end with CRLFCRLF</param>
        </member>
        <member name="M:Fiddler.Proxy.FindGatewayForOrigin(System.String,System.String)">
            <summary>
            This function, when given a scheme host[:port], returns the gateway information of the proxy to forward requests to.
            </summary>
            <param name="sURIScheme">URIScheme: use http, https, or ftp</param>
            <param name="sHostAndPort">Host for which to return gateway information</param>
            <returns>IPEndPoint of gateway to use, or NULL</returns>
        </member>
        <member name="M:Fiddler.Proxy.AcceptConnection(System.IAsyncResult)">
            <summary>
            Accept the connection and pass it off to a handler thread
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:Fiddler.Proxy.Attach">
            <summary>
            Register as the system proxy for WinINET and set the Dynamic registry key for other FiddlerHook
            </summary>
            <returns>True if the proxy registration was successful</returns>
        </member>
        <member name="M:Fiddler.Proxy.ProxyRegistryKeysChanged(System.Object,System.EventArgs)">
            <summary>
            If we get a notice that the proxy registry key has changed, wait 50ms and then check to see
            if the key is pointed at us. If not, raise the alarm.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fiddler.Proxy.VerifyAttached">
            <summary>
            If we are supposed to be "attached", we re-verify the registry keys, and if they are corrupt, notify
            our host of the discrepency.
            </summary>
        </member>
        <member name="M:Fiddler.Proxy.CollectConnectoidAndGatewayInfo">
            <summary>
            This method sets up the connectoid list and updates gateway information. Called by the Attach() method, or 
            called on startup if Fiddler isn't configured to attach automatically.
            </summary>
        </member>
        <member name="M:Fiddler.Proxy.GetFirstRespondingEndpoint(System.String)">
            <summary>
            Given an address list, walks the list until it's able to successfully make a connection.
            Used for finding an available Gateway when we have a list to choose from
            </summary>
            <param name="sHostPortList">A string, e.g. PROXY1:80</param>
            <returns>The IP:Port of the first alive endpoint for the specified host/port</returns>
        </member>
        <member name="M:Fiddler.Proxy._DetermineGatewayIPEndPoints">
            <summary>
            Set internal fields pointing at upstream proxies.
            </summary>
        </member>
        <member name="M:Fiddler.Proxy._setDynamicRegistryKey(System.Boolean)">
            <summary>
            Sets a registry key which indicates that Fiddler is in "Connected" mode. Used by the FiddlerHook Add-on
            </summary>
            <param name="bAttached">TRUE if fiddler is Connected</param>
        </member>
        <member name="M:Fiddler.Proxy.Detach">
            <summary>
            Detach the proxy by setting the registry keys and sending a Windows Message
            </summary>
            <returns>True if the proxy settings were successfully detached</returns>
        </member>
        <member name="M:Fiddler.Proxy.Detach(System.Boolean)">
            <summary>
            Detach the proxy by setting the registry keys and sending a Windows Message
            </summary>
            <returns>True if the proxy settings were successfully detached</returns>
        </member>
        <member name="M:Fiddler.Proxy.Stop">
            <summary>
            Stop the proxy by closing the socket.
            </summary>
        </member>
        <member name="M:Fiddler.Proxy.Start(System.Int32,System.Boolean)">
            <summary>
            Start the proxy by binding to the local port and accepting connections
            </summary>
            <param name="iPort">Port to listen on</param>
            <param name="bAllowRemote">TRUE to allow remote connections</param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Proxy.Dispose">
            <summary>
            Dispose Fiddler's listening socket
            </summary>
        </member>
        <member name="M:Fiddler.Proxy.PurgeServerPipePool">
            <summary>
            Clear the pool of Server Pipes. May be called by extensions.
            </summary>
        </member>
        <member name="M:Fiddler.Proxy.AssignEndpointCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Assign HTTPS Certificate for this endpoint
            </summary>
            <param name="certHTTPS">Certificate to return to clients who connect</param>
        </member>
        <member name="M:Fiddler.Proxy.AssignGateway(Fiddler.WinINETProxyInfo)">
            <summary>
            Sets the upstream gateway to match the specified ProxyInfo
            </summary>
            <param name="oPI"></param>
        </member>
        <member name="M:Fiddler.Proxy.ActAsHTTPSEndpointForHostname(System.String)">
            <summary>
            Generate or find a certificate for this endpoint
            </summary>
            <param name="sHTTPSHostname">Subject FQDN</param>
            <returns>TRUE if the certificate could be found/generated, false otherwise</returns>
        </member>
        <member name="M:Fiddler.Proxy.GetGatewayInformation">
            <summary>
            Return a simple string indicating what upstream proxy/gateway is in use.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Proxy.ShowGatewayInformation">
            <summary>
            Show a message box indicating what upstream gateway/proxy is in use
            </summary>
        </member>
        <member name="P:Fiddler.Proxy.ListenPort">
            <summary>
            The port on which this instance is listening
            </summary>
        </member>
        <member name="P:Fiddler.Proxy.IsAttached">
            <summary>
            Returns true if Fiddler believes it is currently registered as the Local System proxy
            </summary>
        </member>
        <member name="E:Fiddler.Proxy.DetachedUnexpectedly">
            <summary>
            This event handler fires when Fiddler detects that it is (unexpectedly) no longer the system's registered proxy
            </summary>
        </member>
        <member name="T:Fiddler.ProxyBypassList">
            <summary>
            This class maintains the Proxy Bypass List for the upstream gateway. 
            In the constructor, pass the desired proxy bypass string, as retrieved from WinINET for the Fiddler Options screen.
            Then, call the IsBypass(sTarget) method to determine if the Gateway should be bypassed
            </summary>
        </member>
        <member name="F:Fiddler.ProxyBypassList._RegExBypassList">
            <summary>
            List of regular expressions for matching against request Scheme://HostPort.
            NB: This list is either null or contains at least one item.
            </summary>
        </member>
        <member name="F:Fiddler.ProxyBypassList._BypassOnLocal">
            <summary>
            Boolean flag indicating whether the bypass list contained a &lt;local&gt; token.
            </summary>
        </member>
        <member name="M:Fiddler.ProxyBypassList.#ctor(System.String)">
            <summary>
            Pass the desired proxy bypass string retrieved from WinINET.
            </summary>
            <param name="sBypassList"></param>
        </member>
        <member name="M:Fiddler.ProxyBypassList.IsBypass(System.String,System.String)">
            <summary>
            Given the rules for this bypasslist, should this target bypass the proxy?
            </summary>
            <param name="sScheme">The URI Scheme</param>
            <param name="sHostAndPort">The Host and PORT</param>
            <returns>True if this request should not be sent to the gateway proxy</returns>
        </member>
        <member name="M:Fiddler.ProxyBypassList.AssignBypassList(System.String)">
            <summary>
            Convert the string representing the bypass list into an array of rules escaped and ready to be turned into regular expressions
            </summary>
            <param name="sBypassList"></param>
        </member>
        <member name="P:Fiddler.ProxyBypassList.HasEntries">
            <summary>
            Does the bypassList contain any rules at all?
            </summary>
        </member>
        <member name="F:Fiddler.WinINETConnectoid.sConnectionName">
            <summary>
            The DisplayName for this Connection
            </summary>
        </member>
        <member name="F:Fiddler.WinINETConnectoid.bIsHooked">
            <summary>
            Is this Connectoid expected to be pointed at Fiddler?
            </summary>
        </member>
        <member name="F:Fiddler.WinINETConnectoid.oOriginalProxyInfo">
            <summary>
            The proxy settings collected from this connection before Fiddler was attached.
            </summary>
        </member>
        <member name="T:Fiddler.WinINETConnectoids">
            <summary>
            The WinINET Connectoids class contains the RAS/WinINET "connectoids" seen inside IE's Tools > Internet Options > Connections.
            This class exposes methods to retrieve and update the proxy information for each connectoid in the list.
            </summary>
            <remarks>
            TODO: The methods of the class are not thread-safe and probably should be.
            TODO: Need to refactor visibility here. Right now, _oConnectoids is (internal) instead of (private) because the 
            Options dialog iterates the list. And about:connectoids wants access too. Eventually ought to wrap as a ReadOnlyCollection getter
            </remarks>
        </member>
        <member name="F:Fiddler.WinINETConnectoids._oConnectoids">
            <summary>
            Dictionary of all Connectoids, indexed by the Connectoid's Name
            </summary>
        </member>
        <member name="M:Fiddler.WinINETConnectoids.#ctor">
            <summary>
            Expensive Call. Enumerates all Connectoids using the RAS APIs, then determines the proxy information
            for each connectoid. 
            </summary>
        </member>
        <member name="M:Fiddler.WinINETConnectoids.GetDefaultConnectionGatewayInfo">
            <summary>
            Return the configured default connectoid's proxy information.
            </summary>
            <returns>Either proxy information from "DefaultLAN" or the user-specified connectoid</returns>
        </member>
        <member name="M:Fiddler.WinINETConnectoids.MarkDefaultLANAsUnhooked">
            <summary>
            Called when direct Registry groveling determines that the Default LAN connection's proxy was changed but InternetQueryOption
            hasn't yet noticed.
            </summary>
        </member>
        <member name="M:Fiddler.WinINETConnectoids.MarkUnhookedConnections(System.String)">
            <summary>
            Enumerates all of the connectoids and determines if the bIsHooked field is incorrect. If so, correct the value 
            and return TRUE to indicate that work was done.
            </summary>
            <param name="sLookFor">The Proxy:Port string to look for (e.g. Config.FiddlerListenHostPort)</param>
            <returns>TRUE if any of the connectoids' Hook state was inaccurate.</returns>
        </member>
        <member name="M:Fiddler.WinINETConnectoids.HookConnections(Fiddler.WinINETProxyInfo)">
            <summary>
            Updates all (or CONFIG.sHookConnectionNamed-specified) connectoids to point at the argument-provided proxy information.
            </summary>
            <param name="oNewInfo">The proxy info to set into the Connectoid</param>
            <returns>TRUE if updating at least one connectoid was successful</returns>
        </member>
        <member name="M:Fiddler.WinINETConnectoids.UnhookAllConnections">
            <summary>
            Restore original proxy settings for any connectoid we changed.
            </summary>
            <returns>FALSE if any connectoids failed to unhook</returns>
        </member>
        <member name="M:Fiddler.RegistryWatcher.WatchKey(Microsoft.Win32.RegistryHive,System.String,System.EventHandler)">
            <summary>
            Watch a registry key for changes to its values.
            </summary>
            <param name="registryHive">The Registry Hive in which the key lives</param>
            <param name="subKey">The key, e.g. \Software\Microsoft\Fiddler2\</param>
            <param name="oToNotify">The Event Handler to invoke when a change occurs.</param>
            <returns>A new RegistryWatcher object.</returns>
        </member>
        <member name="M:Fiddler.RegistryWatcher.Start">
            <summary>
            Start monitoring.
            </summary>
        </member>
        <member name="M:Fiddler.RegistryWatcher.Stop">
            <summary>
            Stops the monitoring thread.
            </summary>
        </member>
        <member name="E:Fiddler.RegistryWatcher.KeyChanged">
            <summary>
            Fires when the specified registry key has changed.
            </summary>
        </member>
        <member name="T:Fiddler.ServerChatter">
            <summary>
            The ServerChatter object is responsible for transmitting the Request to the destination server and retrieving its Response.
            </summary>
            <remarks>
            This class maintains its own PipeReadBuffer that it fills from the created or reused ServerPipe. After it determines that
            a complete response is present, it allows the caller to grab that array using the TakeEntity method. If
            unsatisfied with the result (e.g. a network error), the caller can call Initialize() and SendRequest() again.
            </remarks>
        </member>
        <member name="F:Fiddler.ServerChatter.s_cbServerReadBuffer">
            <summary>
            Size of buffer passed to pipe.Receive when reading from the server
            </summary>
            <remarks>
            PERF: Currently, I use [32768]; but I'd assume bigger buffers are faster. Does ReceiveBufferSize/SO_RCVBUF figure in here?
            Anecdotal data suggests that current reads rarely fill the full 32k buffer.
            </remarks>
        </member>
        <member name="F:Fiddler.ServerChatter.s_WATCHDOG_INTERVAL">
            <summary>
            Interval, in milliseconds, after which Fiddler will check to see whether a response should continue to be read. Otherwise,
            a never-ending network stream can accumulate ever larger amounts of data that will never be seen by the garbage collector.
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.pipeServer">
            <summary>
            The pipeServer represents Fiddler's connection to the server.
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_session">
            <summary>
            The session to which this ServerChatter belongs
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_inHeaders">
            <summary>
            The inbound headers on this response
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_bWasForwarded">
            <summary>
            Indicates whether this request was sent to a (non-SOCKS) Gateway, which influences whether the protocol and host are
            mentioned in the Request line
            When True, the session should have SessionFlags.SentToGateway set.
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_responseData">
            <summary>
            Buffer holds this response's data as it is read from the pipe.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Fiddler.ServerChatter.m_responseTotalDataCount" -->
        <member name="F:Fiddler.ServerChatter.m_iEntityBodyOffset">
            <summary>
            Pointer to first byte of Entity body (or to the start of the next set of headers in the case where there's a HTTP/1xx intermediate header)
            Note: This gets reset to 0 if we're streaming and dropping the response body.
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_iBodySeekProgress">
            <summary>
            Optimization: tracks how far we've looked into the Request when determining iEntityBodyOffset
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_bLeakedHeaders">
            <summary>
            True if final (non-1xx) HTTP Response headers have been returned to the client.
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_lngLeakedOffset">
            <summary>
            Indicates how much of _responseData buffer has already been streamed to the client
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter.m_lngLastChunkInfoOffset">
            <summary>
            Position in responseData of the start of the latest parsed chunk size information
            </summary>
        </member>
        <member name="F:Fiddler.ServerChatter._esState">
            <summary>
            Locals used by the Connect-to-Host state machine
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.#ctor(Fiddler.Session,System.String)">
            <summary>
            Create a ServerChatter object and initialize its headers from the specified string
            </summary>
            <param name="oSession"></param>
            <param name="sHeaders"></param>
        </member>
        <member name="M:Fiddler.ServerChatter.Initialize(System.Boolean)">
            <summary>
            Reset the response-reading fields on the object. Also used on a retry.
            </summary>
            <param name="bAllocatePipeReadBuffer">If TRUE, allocates a buffer (m_responseData) to read from a pipe. If FALSE, nulls m_responseData.</param>
        </member>
        <member name="M:Fiddler.ServerChatter._PeekAtBody">
            <summary>
            Peek at the current response body and return it as an array
            </summary>
            <returns>The response body as an array, or byte[0]</returns>
        </member>
        <member name="M:Fiddler.ServerChatter.TakeEntity">
            <summary>
            Get the response body byte array from the PipeReadBuffer, then dispose of it.
            
            WARNING: This eats all of the bytes in the Pipe, even if that includes bytes of a 
            future, as-yet-unrequested response. Fiddler does not pipeline requests, so that works okay for now.
            For now, the caller should validate that the returned entity is of the expected size (e.g. based on Content-Length)
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.HeadersAvailable">
             <summary>
             Scans responseData stream for the \r\n\r\n (or variants) sequence
             which indicates that the header block is complete.
            
             SIDE EFFECTS:
                 iBodySeekProgress is updated and maintained across calls to this function
                 iEntityBodyOffset is updated if the end of headers is found
             </summary>
             <returns>True, if responseData contains a full set of headers</returns>
        </member>
        <member name="M:Fiddler.ServerChatter.ParseResponseForHeaders">
            <summary>
            Parse the HTTP Response into Headers and Body.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.ServerChatter.GetHeaders">
            <summary>
            Attempt to pull the final (non-1xx) Headers from the stream. If HTTP/100 messages are found, the method
            will recurse into itself to find the next set of headers.
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter._deleteInformationalMessage">
            <summary>
            Deletes a single HTTP/1xx header block from the Response stream
            and adjusts all header-reading state to start over from the top of the stream. 
            Note: If 'fiddler.network.leakhttp1xx' is TRUE, then the 1xx message will have been leaked before calling this method.
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.releaseServerPipe">
            <summary>
            Adjusts PipeServer's ReusePolicy if response headers require closure. Then calls _detachServerPipe()
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter._detachServerPipe">
            <summary>
            Queues or End()s the ServerPipe, depending on its ReusePolicy
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.SIDsMatch(System.Int32,System.String,System.String)">
            <summary>
            Determines whether a given PIPE is suitable for a given Session, based on that Session's SID
            </summary>
            <param name="iPID">The Client Process ID, if any</param>
            <param name="sIDSession">The base (no PID) PoolKey expected by the session</param>
            <param name="sIDPipe">The pipe's pool key</param>
            <returns>TRUE if the connection should be used, FALSE otherwise</returns>
        </member>
        <member name="M:Fiddler.ServerChatter._smHandleConnectionException(System.Exception)">
            <summary>
            If a Connection cannot be established, we need to report the failure to our caller
            </summary>
            <param name="eX"></param>
        </member>
        <member name="M:Fiddler.ServerChatter.CreateConnectedSocket(System.Net.IPEndPoint[],Fiddler.Session)">
            <summary>
            Given an address list and port, attempts to create a socket to the first responding host in the list (retrying via DNS Failover if needed).
            </summary>
            <param name="arrDest">IPEndpoints to attempt to reach</param>
            <param name="_oSession">Session object to annotate with timings and errors</param>
            <returns>Connected Socket. Throws Exceptions on errors.</returns>
        </member>
        <member name="M:Fiddler.ServerChatter.StreamRequestBody">
            <summary>
            If the Session was configured to stream the request body, we need to read from the client
            and send it to the server here.
            </summary>
            <returns>
            FALSE on transfer error, TRUE otherwise.
            </returns>
        </member>
        <member name="M:Fiddler.ServerChatter.SendRequest">
            <summary>
            Sends (or resends) the Request to the server or upstream proxy. If the request is a CONNECT and there's no
            gateway, this method ~only~ establishes the connection to the target, but does NOT send a request.
            
            Note: THROWS on failures
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter._MayRetryWhenSendFailed">
            <summary>
            May request be resent on a different connection because the .Send() of the request did not complete?
            </summary>
            <returns>TRUE if the request may be resent</returns>
        </member>
        <member name="M:Fiddler.ServerChatter._SOCKSifyConnection(System.String,System.Int32,System.Net.Sockets.Socket)">
            <summary>
            Performs a SOCKSv4A handshake on the socket
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter._BuildSOCKS4ConnectHandshakeForTarget(System.String,System.Int32)">
            <summary>
            Build the SOCKS4 outbound connection handshake as a byte array.
            http://en.wikipedia.org/wiki/SOCKS#SOCKS4a
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter._ReturnFileReadError(System.String,System.String)">
            <summary>
            Replaces body with an error message
            </summary>
            <param name="sRemoteError">Error to send if client was remote</param>
            <param name="sTrustedError">Error to send if cilent was local</param>
        </member>
        <member name="M:Fiddler.ServerChatter.GenerateHeadersForLocalFile(System.String)">
            <summary>
            The Session object will call this method if it wishes to stream a file from disk instead
            of loading it into memory. This method sets default headers.
            </summary>
            <param name="sFilename"></param>
        </member>
        <member name="M:Fiddler.ServerChatter.ReadResponseFromFile(System.String,System.String)">
            <summary>
            Loads a HTTP response from a file
            </summary>
            <param name="sFilename">The name of the file from which a response should be loaded</param>
            <returns>False if the file wasn't found. Throws on other errors.</returns>
        </member>
        <member name="M:Fiddler.ServerChatter.ReadResponse">
            <summary>
            Reads the response from the ServerPipe.
            </summary>
            <returns>TRUE if a response was read</returns>
        </member>
        <member name="M:Fiddler.ServerChatter._EnableStreamingIfAppropriate">
            <summary>
            When the headers first arrive, update bBufferResponse based on their contents.
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.IsWorkableFTPRequest">
            <summary>
            Detects whether this is an direct FTP request and if so executes it and returns true.
            </summary>
            <returns>FALSE if the request wasn't FTP or wasn't direct.</returns>
        </member>
        <member name="M:Fiddler.ServerChatter.ReleaseStreamedData">
            <summary>
            Remove from memory the response data that we have already returned to the client.
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.ReleaseStreamedChunkedData">
            <summary>
            Remove from memory the response data that we have already returned to the client, up to the last chunk
            size indicator, which we need to keep around for chunk-integrity purposes.
            </summary>
        </member>
        <member name="M:Fiddler.ServerChatter.LeakResponseBytes">
            <summary>
            Leak the current bytes of the response to client. We wait for the full header
            set before starting to stream for a variety of impossible-to-change reasons.
            </summary>
            <returns>Returns TRUE if response bytes were leaked, false otherwise (e.g. write error). THROWS if "fiddler.network.streaming.abortifclientaborts" is TRUE</returns>
        </member>
        <member name="M:Fiddler.ServerChatter._PoisonPipe">
            <summary>
            Mark this connection as non-reusable
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter._PeekDownloadProgress">
            <summary>
            Peek at number of bytes downloaded thus far.
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.MIMEType">
            <summary>
            Get the MIME type (sans Character set or other attributes) from the HTTP Content-Type response header, or String.Empty if missing.
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.iTTFB">
            <summary>
            DEPRECATED: You should use the Timers object on the Session object instead.
            The number of milliseconds between the start of sending the request to the server to the first byte of the server's response
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.iTTLB">
            <summary>
            DEPRECATED: You should use the Timers object on the Session object instead.
            The number of milliseconds between the start of sending the request to the server to the last byte of the server's response.
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.bWasForwarded">
            <summary>
            Was this request forwarded to a gateway?
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.bServerSocketReused">
            <summary>
            Was this request serviced from a reused server connection?
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.headers">
            <summary>
            The HTTP headers of the server's response
            </summary>
        </member>
        <member name="P:Fiddler.ServerChatter.Item(System.String)">
            <summary>
            Simple indexer into the Response Headers object
            </summary>
        </member>
        <member name="T:Fiddler.ServerChatter.MakeConnectionExecutionState">
            <summary>
            The ExecutionState object holds information that is used by the Connect-to-Host state machine
            </summary>
        </member>
        <member name="T:Fiddler.Session">
            <summary>
            The Session object manages the complete HTTP session including the UI listitem, the ServerChatter, and the ClientChatter.
            </summary>
        </member>
        <member name="F:Fiddler.Session.bTrySPNTokenObject">
            <summary>
            Should we try to use the SPNToken type?
            Cached for performance reasons.
            ISSUE: It's technically possible to use FiddlerCorev2/v3 on .NET/4.5 but we won't set this field if you do that.
            </summary>
        </member>
        <member name="F:Fiddler.Session.__WebRequestForAuth">
            <summary>
            Sorta hacky, we may use a .NET WebRequest object to generate a valid NTLM/Kerberos response if the server
            demands authentication and the Session is configured to automatically respond.
            </summary>
        </member>
        <member name="F:Fiddler.Session.__oTunnel">
            <summary>
            Used if the Session is bound to a WebSocket or CONNECTTunnel
            </summary>
        </member>
        <member name="F:Fiddler.Session.__sResponseFileToStream">
            <summary>
            File to stream if responseBodyBytes is null
            </summary>
        </member>
        <member name="M:Fiddler.Session.UNSTABLE_SetBitFlag(Fiddler.SessionFlags,System.Boolean)">
            <summary>
            DO NOT USE. TEMPORARY WHILE REFACTORING VISIBILITY OF MEMBERS
            </summary>
            <param name="FlagsToSet"></param>
            <param name="b"></param>
        </member>
        <member name="M:Fiddler.Session.SetBitFlag(Fiddler.SessionFlags,System.Boolean)">
            <summary>
            Sets or unsets the specified SessionFlag(s)
            </summary>
            <param name="FlagsToSet">SessionFlags</param>
            <param name="b">Desired set value</param>
        </member>
        <member name="M:Fiddler.Session.isFlagSet(Fiddler.SessionFlags)">
            <summary>
            Test the session's BitFlags
            </summary>
            <param name="FlagsToTest">One or more (OR'd) SessionFlags</param>
            <returns>TRUE if ALL specified flag(s) are set</returns>
        </member>
        <member name="M:Fiddler.Session.isAnyFlagSet(Fiddler.SessionFlags)">
            <summary>
            Test the session's BitFlags
            </summary>
            <param name="FlagsToTest">One or more (OR'd) SessionFlags</param>
            <returns>TRUE if ANY of specified flag(s) are set</returns>
        </member>
        <member name="F:Fiddler.Session.nextSession">
            <summary>
            When a client socket is reused, this field holds the next Session until its execution begins
            </summary>
        </member>
        <member name="F:Fiddler.Session.bBufferResponse">
            <summary>
            Should response be buffered for tampering.
            </summary>
            <remarks>ARCH: This should have been a property instead of a field, so we could throw an InvalidStateException if code tries to manipulate this value after the response has begun</remarks>
        </member>
        <member name="F:Fiddler.Session.Timers">
            <summary>
            Timers stored as this Session progresses
            </summary>
        </member>
        <member name="F:Fiddler.Session._bAllowClientPipeReuse">
            <summary>
            Field is set to False if socket is poisoned due to HTTP errors.
            </summary>
        </member>
        <member name="F:Fiddler.Session.oResponse">
            <summary>
            Object representing the HTTP Response.
            </summary>
        </member>
        <member name="F:Fiddler.Session.oRequest">
            <summary>
            Object representing the HTTP Request.
            </summary>
        </member>
        <member name="F:Fiddler.Session.oFlags">
            <summary>
            Fiddler-internal flags set on the Session.
            </summary>
            <remarks>TODO: ARCH: This shouldn't be exposed directly; it should be wrapped by a ReaderWriterLockSlim to prevent
            exceptions while enumerating the flags for storage, etc</remarks>
        </member>
        <member name="F:Fiddler.Session.requestBodyBytes">
            <summary>
            Contains the bytes of the request body.
            </summary>
        </member>
        <member name="F:Fiddler.Session.responseBodyBytes">
            <summary>
            Contains the bytes of the response body.
            </summary>
        </member>
        <member name="F:Fiddler.Session.m_clientIP">
            <summary>
            IP Address of the client for this session.
            </summary>
        </member>
        <member name="F:Fiddler.Session.m_clientPort">
            <summary>
            Client port attached to Fiddler.
            </summary>
        </member>
        <member name="F:Fiddler.Session.m_hostIP">
            <summary>
            IP Address of the server for this session.
            </summary>
        </member>
        <member name="F:Fiddler.Session.oSyncEvent">
            <summary>
            Event object used for pausing and resuming the thread servicing this session
            </summary>
        </member>
        <member name="M:Fiddler.Session.HTTPMethodIs(System.String)">
            <summary>
            Returns TRUE if the Session's HTTP Method is available and matches the target method.
            </summary>
            <param name="sTestFor">The target HTTP Method being compared.</param>
            <returns>true, if the method is specified and matches sTestFor (case-insensitive); otherwise false.</returns>
        </member>
        <member name="M:Fiddler.Session.HostnameIs(System.String)">
            <summary>
            Returns TRUE if the Session's target hostname (no port) matches sTestHost (case-insensitively).
            </summary>
            <param name="sTestHost">The host to which this session's host should be compared.</param>
            <returns>True if this session is targeted to the specified host.</returns>
        </member>
        <member name="M:Fiddler.Session._MakeSafeFilename(System.String)">
            <summary>
            Replaces any characters in a filename that are unsafe with safe equivalents, and trim to 160 characters.
            </summary>
            <param name="sFilename"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Session._GetSuggestedFilenameExt">
            <summary>
            Examines the MIME type, and if ambiguous, returns sniffs the body.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Session.FireContinueTransaction(Fiddler.Session,Fiddler.Session,Fiddler.ContinueTransactionReason)">
            <summary>
            Notify extensions if this Session naturally led to another (e.g. due to redirect chasing or Automatic Authentication)
            </summary>
            <param name="oOrig">The original session</param>
            <param name="oNew">The new session created</param>
        </member>
        <member name="M:Fiddler.Session.ToHTMLFragment(System.Boolean)">
            <summary>
            Returns HTML representing the Session. Call Utilities.StringToCF_HTML on the result of this function before placing it on the clipboard.
            </summary>
            <param name="HeadersOnly">TRUE if only the headers should be copied.</param>
            <returns>A HTML-formatted fragment representing the current session.</returns>
        </member>
        <member name="M:Fiddler.Session.ToString(System.Boolean)">
            <summary>
            Store this session's request and response to a string.
            </summary>
            <param name="HeadersOnly">If true, return only the request and response headers</param>
            <returns>String representing this session</returns>
        </member>
        <member name="M:Fiddler.Session.ToString">
            <summary>
            Store this session's request and response to a string.
            </summary>
            <returns>A string containing the content of the request and response.</returns>
        </member>
        <member name="M:Fiddler.Session.ThreadResume">
            <summary>
            This method resumes the Session's thread in response to "Continue" commands from the UI
            </summary>
        </member>
        <member name="M:Fiddler.Session.Ignore">
            <summary>
            Set the SessionFlags.Ignore bit for this Session, also configuring it to stream, drop read data, and bypass event handlers.
            For a CONNECT Tunnel, traffic will be blindly shuffled back and forth. Session will be hidden.
            </summary>
        </member>
        <member name="M:Fiddler.Session.CreateAndExecute(System.Object)">
            <summary>
            Called by an AcceptConnection-spawned background thread, create a new session object from a client socket 
            and execute the session
            </summary>
            <param name="oParams">Parameter object defining client socket and endpoint's HTTPS certificate, if present</param>
        </member>
        <member name="M:Fiddler.Session.AcceptHTTPSRequest(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Call this method to AuthenticateAsServer on the client pipe (e.g. Fiddler itself is acting as a HTTPS server). 
            If configured, the pipe will first sniff the request's TLS ClientHello ServerNameIndicator extension.
            </summary>
            <param name="oCert">The default certificate to use</param>
            <returns>TRUE if a HTTPS handshake was achieved; FALSE for any exceptions or other errors.</returns>
        </member>
        <member name="M:Fiddler.Session.COMETPeek">
            <summary>
            Call this function while in the "reading response" state to update the responseBodyBytes array with
            the partially read response.
            </summary>
            <returns>TRUE if the peek succeeded; FALSE if not in the ReadingResponse state</returns>
        </member>
        <member name="M:Fiddler.Session.PoisonServerPipe">
            <summary>
            Prevents the server pipe from this session from being pooled for reuse
            </summary>
        </member>
        <member name="M:Fiddler.Session.PoisonClientPipe">
            <summary>
            Ensures that, after the response is complete, the client socket is closed and not reused.
            Does NOT (and must not) close the pipe.
            </summary>
        </member>
        <member name="M:Fiddler.Session.CloseSessionPipes(System.Boolean)">
            <summary>
            Immediately close client and server sockets. Call in the event of errors-- doesn't queue server pipes for future reuse.
            </summary>
            <param name="bNullThemToo"></param>
        </member>
        <member name="M:Fiddler.Session.Abort">
            <summary>
            Closes both client and server pipes and moves state to Aborted; unpauses thread if paused.
            </summary>
        </member>
        <member name="M:Fiddler.Session.SaveResponseBody">
            <summary>
            Save HTTP response body to Fiddler Captures folder. You likely want to call utilDecodeResponse first.
            </summary>
            <returns>True if the response body was successfully saved</returns>
        </member>
        <member name="M:Fiddler.Session.SaveResponseBody(System.String)">
            <summary>
            Save HTTP response body to specified location. You likely want to call utilDecodeResponse first.
            </summary>
            <param name="sFilename">The name of the file to which the response body should be saved.</param>
            <returns>True if the file was successfully written.</returns>
        </member>
        <member name="M:Fiddler.Session.SaveRequestBody(System.String)">
            <summary>
            Save the request body to a file. You likely want to call utilDecodeRequest first.
            </summary>
            <param name="sFilename">The name of the file to which the request body should be saved.</param>
            <returns>True if the file was successfully written.</returns>
        </member>
        <member name="M:Fiddler.Session.SaveSession(System.String,System.Boolean)">
            <summary>
            Save the request and response to a single file.
            </summary>
            <param name="sFilename">The filename to which the session should be saved.</param>
            <param name="bHeadersOnly">TRUE if only the headers should be written.</param>
        </member>
        <member name="M:Fiddler.Session.SaveRequest(System.String,System.Boolean)">
            <summary>
            Save the request to a file.
            The headers' Request Line will not contain the scheme or host, which is probably not what you want.
            </summary>
            <param name="sFilename">The name of the file to which the request should be saved.</param>
            <param name="bHeadersOnly">TRUE to save only the headers</param>
        </member>
        <member name="M:Fiddler.Session.SaveRequest(System.String,System.Boolean,System.Boolean)">
            <summary>
            Save the request to a file. Throws if file cannot be written.
            </summary>
            <param name="sFilename">The name of the file to which the request should be saved.</param>
            <param name="bHeadersOnly">TRUE to save only the headers.</param>
            <param name="bIncludeSchemeAndHostInPath">TRUE to include the Scheme and Host in the Request Line.</param>
        </member>
        <member name="M:Fiddler.Session.LoadMetadata(System.IO.Stream)">
            <summary>
            Read metadata about this session from a stream. NB: Closes the Stream when done.
            </summary>
            <param name="strmMetadata">The stream of XML text from which session metadata will be loaded.</param>
            <returns>True if the Metadata was successfully loaded; False if any exceptions were trapped.</returns>
        </member>
        <member name="M:Fiddler.Session.SaveMetadata(System.String)">
            <summary>
            Writes this session's metadata to a file.
            </summary>
            <param name="sFilename">The name of the file to which the metadata should be saved in XML format.</param>
            <returns>True if the file was successfully written.</returns>
        </member>
        <member name="M:Fiddler.Session.SaveResponse(System.String,System.Boolean)">
            <summary>
            Saves the response (headers and body) to a file
            </summary>
            <param name="sFilename">The File to write</param>
            <param name="bHeadersOnly">TRUE if only heaers should be written</param>
        </member>
        <member name="M:Fiddler.Session.WriteMetadataToStream(System.IO.Stream)">
            <summary>
            Write the metadata about this Session to a stream. The Stream is left open!
            </summary>
            <param name="strmMetadata">The Stream to write to</param>
        </member>
        <member name="M:Fiddler.Session.WriteRequestToStream(System.Boolean,System.Boolean,System.IO.Stream)">
            <summary>
            Write the session's Request to the specified stream 
            </summary>
            <param name="bHeadersOnly">TRUE if only the headers should be be written</param>
            <param name="bIncludeProtocolAndHostWithPath">TRUE if the Scheme and Host should be written in the Request Line</param>
            <param name="oFS">The Stream to which the request should be written</param>
            <returns>True if the request was written to the stream. False if the request headers do not exist. Throws on other stream errors.</returns>
        </member>
        <member name="M:Fiddler.Session.WriteRequestToStream(System.Boolean,System.Boolean,System.Boolean,System.IO.Stream)">
            <summary>
            Write the session's Request to the specified stream 
            </summary>
            <param name="bHeadersOnly">TRUE if only the headers should be be written</param>
            <param name="bIncludeProtocolAndHostWithPath">TRUE if the Scheme and Host should be written in the Request Line</param>
            <param name="bEncodeIfBinary">TRUE if binary bodies should be encoded in base64 for text-safe transport (e.g. used by Composer drag/drop)</param>
            <param name="oFS">The Stream to which the request should be written</param>
            <returns>True if the request was written to the stream. False if the request headers do not exist. Throws on other stream errors.</returns>
        </member>
        <member name="M:Fiddler.Session.WriteResponseToStream(System.IO.Stream,System.Boolean)">
            <summary>
            Write the session's Response to the specified stream
            </summary>
            <param name="oFS">The stream to which the response should be written</param>
            <param name="bHeadersOnly">TRUE if only the headers should be written</param>
            <returns>TRUE if the response was written to the stream. False if the response headers do not exist. Throws on other stream errors.</returns>
        </member>
        <member name="M:Fiddler.Session.WriteToStream(System.IO.Stream,System.Boolean)">
            <summary>
            Write the session to the specified stream
            </summary>
            <param name="oFS">The stream to which the session should be written</param>
            <param name="bHeadersOnly">TRUE if only the request and response headers should be written</param>
            <returns>False on any exceptions; True otherwise</returns>
        </member>
        <member name="M:Fiddler.Session.LoadRequestBodyFromFile(System.String)">
            <summary>
            Replace HTTP request body using the specified file.
            </summary>
            <param name="sFilename">The file containing the request</param>
            <returns>True if the file was successfully loaded as the request body</returns>
        </member>
        <member name="M:Fiddler.Session.LoadResponseFromStream(System.IO.Stream,System.String)">
            <summary>
            Replace HTTP response headers and body using the specified stream.
            </summary>
            <param name="sFilename">The stream containing the response.</param>
            <returns>True if the Stream was successfully loaded.</returns>
        </member>
        <member name="M:Fiddler.Session.LoadResponseFromFile(System.String)">
            <summary>
            Replace HTTP response headers and body using the specified file.
            </summary>
            <param name="sFilename">The file containing the response.</param>
            <returns>True if the file was successfully loaded.</returns>
        </member>
        <member name="M:Fiddler.Session.GetRequestBodyAsString">
            <summary>
            Return a string generated from the request body, decoding it and converting from a codepage if needed. Throws on errors.
            </summary>
            <returns>A string containing the request body.</returns>
        </member>
        <member name="M:Fiddler.Session.GetResponseBodyAsString">
            <summary>
            Return a string generated from the response body, decoding it and converting from a codepage if needed. Throws on errors.
            </summary>
            <returns>A string containing the response body.</returns>
        </member>
        <member name="M:Fiddler.Session.GetRequestBodyEncoding">
            <summary>
            Find the text encoding of the request
            WARNING: Will not decompress body to scan for indications of the character set
            </summary>
            <returns>Returns the Encoding of the requestBodyBytes</returns>
        </member>
        <member name="M:Fiddler.Session.GetResponseBodyEncoding">
            <summary>
            Find the text encoding of the response
            WARNING: Will not decompress body to scan for indications of the character set
            </summary>
            <returns>The Encoding of the responseBodyBytes</returns>
        </member>
        <member name="M:Fiddler.Session.uriContains(System.String)">
            <summary>
            Returns true if the absolute request URI contains the specified string. Case-insensitive.
            </summary>
            <param name="sLookfor">Case-insensitive string to find</param>
            <returns>TRUE if the URI contains the string</returns>
        </member>
        <member name="M:Fiddler.Session.utilDecodeResponse">
            <summary>
            Removes chunking and HTTP Compression from the Response. Adds or updates Content-Length header.
            </summary>
            <returns>Returns TRUE if the response was decoded; returns FALSE on failure, or if response didn't have headers that showed encoding.</returns>
        </member>
        <member name="M:Fiddler.Session.utilDecodeResponse(System.Boolean)">
            <summary>
            Removes chunking and HTTP Compression from the Response. Adds or updates Content-Length header.
            </summary>
            <param name="bSilent">TRUE if error messages should be suppressed. False otherwise.</param>
            <returns>TRUE if the decoding was successsful.</returns>
        </member>
        <member name="M:Fiddler.Session.utilDecodeRequest">
            <summary>
            Removes chunking and HTTP Compression from the Request. Adds or updates Content-Length header.
            </summary>
            <returns>Returns TRUE if the request was decoded; returns FALSE on failure, or if request didn't have headers that showed encoding.</returns>
        </member>
        <member name="M:Fiddler.Session.utilGZIPRequest">
            <summary>
            Use GZIP to compress the request body. Throws exceptions to caller.
            </summary>
            <returns>TRUE if compression succeeded</returns>
        </member>
        <member name="M:Fiddler.Session.utilGZIPResponse">
            <summary>
            Use GZIP to compress the response body. Throws exceptions to caller.
            </summary>
            <returns>TRUE if compression succeeded</returns>
        </member>
        <member name="M:Fiddler.Session.utilDeflateResponse">
            <summary>
            Use DEFLATE to compress the response body. Throws exceptions to caller.
            </summary>
            <returns>TRUE if compression succeeded</returns>
        </member>
        <member name="M:Fiddler.Session.utilBZIP2Response">
            <summary>
            Use BZIP2 to compress the response body. Throws exceptions to caller.
            </summary>
            <returns>TRUE if compression succeeded</returns>
        </member>
        <member name="M:Fiddler.Session.utilChunkResponse(System.Int32)">
            <summary>
            Introduces HTTP Chunked encoding on the response body
            </summary>
            <param name="iSuggestedChunkCount">The number of chunks to try to create</param>
            <returns>TRUE if the chunking could be performed.</returns>
        </member>
        <member name="M:Fiddler.Session.utilReplaceInRequest(System.String,System.String)">
            <summary>
            Perform a string replacement on the request body. Adjusts the Content-Length header if needed.
            </summary>
            <param name="sSearchFor">The case-sensitive string to search for.</param>
            <param name="sReplaceWith">The text to replace.</param>
            <returns>TRUE if one or more replacements occurred.</returns>
        </member>
        <member name="M:Fiddler.Session.utilCreateResponseAndBypassServer">
            <summary>
            Call inside OnBeforeRequest to create a response object and bypass the server.
            </summary>
        </member>
        <member name="M:Fiddler.Session.utilReplaceRegexInResponse(System.String,System.String)">
            <summary>
            Perform a regex-based string replacement on the response body. Adjusts the Content-Length header if needed. 
            </summary>
            <param name="sSearchForRegEx">The regular expression used to search the body. Specify RegEx Options via leading Inline Flags, e.g. (?im) for case-Insensitive Multi-line.</param>
            <param name="sReplaceWithExpression">The text or expression used to replace</param>
            <returns>TRUE if replacements occured</returns>
        </member>
        <member name="M:Fiddler.Session.utilReplaceInResponse(System.String,System.String)">
            <summary>
            Perform a string replacement on the response body (potentially multiple times). Adjust the Content-Length header if needed. 
            </summary>
            <param name="sSearchFor">String to find (case-sensitive)</param>
            <param name="sReplaceWith">String to use to replace</param>
            <returns>TRUE if replacements occurred</returns>
        </member>
        <member name="M:Fiddler.Session.utilReplaceOnceInResponse(System.String,System.String,System.Boolean)">
            <summary>
            Perform a one-time string replacement on the response body. Adjust the Content-Length header if needed. 
            </summary>
            <param name="sSearchFor">String to find (case-sensitive)</param>
            <param name="sReplaceWith">String to use to replace</param>
            <param name="bCaseSensitive">TRUE for Case-Sensitive</param>
            <returns>TRUE if a replacement occurred</returns>
        </member>
        <member name="M:Fiddler.Session.utilSetRequestBody(System.String)">
            <summary>
            Replaces the request body with sString. Sets Content-Length header and removes Transfer-Encoding/Content-Encoding.
            </summary>
            <param name="sString">The desired request Body as a string</param>
        </member>
        <member name="M:Fiddler.Session.utilSetResponseBody(System.String)">
            <summary>
            Replaces the response body with sString. Sets Content-Length header and removes Transfer-Encoding/Content-Encoding
            </summary>
            <param name="sString">The desired response Body as a string</param>
        </member>
        <member name="M:Fiddler.Session.utilPrependToResponseBody(System.String)">
            <summary>
            Add a string to the top of the response body, updating Content-Length. (Call utilDecodeResponse first!)
            </summary>
            <param name="sString">The string to prepend</param>
        </member>
        <member name="M:Fiddler.Session.utilFindInRequest(System.String,System.Boolean)">
            <summary>
            Find a string in the request body. Return its index, or -1.
            </summary>
            <param name="sSearchFor">Term to search for</param>
            <param name="bCaseSensitive">Require case-sensitive match?</param>
            <returns>Location of sSearchFor,or -1</returns>
        </member>
        <member name="M:Fiddler.Session.utilFindInResponse(System.String,System.Boolean)">
            <summary>
            Find a string in the response body. Return its index, or -1.
            </summary>
            <param name="sSearchFor">Term to search for</param>
            <param name="bCaseSensitive">Require case-sensitive match?</param>
            <returns>Location of sSearchFor,or -1</returns>
        </member>
        <member name="M:Fiddler.Session.ResetSessionCounter">
            <summary>
            Reset the SessionID counter to 0. This method can lead to confusing UI, so use sparingly.
            </summary>
        </member>
        <member name="M:Fiddler.Session.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Create a Session object from two byte[] representing request and response.
            </summary>
            <param name="arrRequest">The client data bytes</param>
            <param name="arrResponse">The server data bytes</param>
        </member>
        <member name="M:Fiddler.Session.#ctor(Fiddler.SessionData)">
            <summary>
            Create a Session object from a (serializable) SessionData object
            </summary>
            <param name="oSD"></param>
        </member>
        <member name="M:Fiddler.Session.#ctor(System.Byte[],System.Byte[],Fiddler.SessionFlags)">
            <summary>
            Create a Session object from two byte[] representing request and response. This is used when loading a Session Archive Zip.
            </summary>
            <param name="arrRequest">The client data bytes</param>
            <param name="arrResponse">The server data bytes</param>
            <param name="oSF">SessionFlags for this session</param>
        </member>
        <member name="M:Fiddler.Session.#ctor(Fiddler.ClientPipe,Fiddler.ServerPipe)">
            <summary>
            Creates a new session and attaches it to the pipes passed as arguments
            </summary>
            <param name="clientPipe">The client pipe from which the request is read and to which the response is written.</param>
            <param name="serverPipe">The server pipe to which the request is sent and from which the response is read. May be null.</param>
        </member>
        <member name="M:Fiddler.Session.#ctor(Fiddler.HTTPRequestHeaders,System.Byte[])">
            <summary>
            Initialize a new session from a given request headers and body request builder data. Note: No Session ID is assigned here.
            </summary>
            <param name="oRequestHeaders">NB: If you're copying an existing request, use oRequestHeaders.Clone()</param>
            <param name="arrRequestBody">The bytes of the request's body</param>
        </member>
        <member name="M:Fiddler.Session.#ctor(Fiddler.Session)">
            <summary>
            Copy Constructor. <seealso cref="!:BuildFromData()"/>
            </summary>
            <param name="toDeepCopy">Session to clone into a new Session instance</param>
        </member>
        <member name="M:Fiddler.Session.BuildFromData(System.Boolean,Fiddler.HTTPRequestHeaders,System.Byte[],Fiddler.HTTPResponseHeaders,System.Byte[],Fiddler.SessionFlags)">
            <summary>
            Factory constructor
            </summary>
            <param name="bClone"></param>
            <param name="headersRequest"></param>
            <param name="arrRequestBody"></param>
            <param name="headersResponse"></param>
            <param name="arrResponseBody"></param>
            <param name="oSF"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Session.Execute(System.Object)">
            <summary>
            Called when the Session is ready to begin processing. Eats exceptions to prevent unhandled exceptions on background threads from killing the application.
            </summary>
            <param name="objThreadState">Unused parameter (required by ThreadPool)</param>
        </member>
        <member name="F:Fiddler.Session._pState">
            <summary>
            Current step in the SessionProcessing State Machine
            </summary>
        </member>
        <member name="M:Fiddler.Session.InnerExecute">
            <summary>
            InnerExecute() implements Fiddler's HTTP Pipeline
            </summary>
        </member>
        <member name="M:Fiddler.Session._smInitiateRPCStreaming">
            <summary>
            Initiate bi-directional streaming on the RPC connection
            </summary>
        </member>
        <member name="M:Fiddler.Session._EnsureStateAtLeast(Fiddler.SessionStates)">
            <summary>
            Ensure that the Session's state is >= ss, updating state if necessary
            </summary>
            <param name="ss">TargetState</param>
        </member>
        <member name="M:Fiddler.Session._MayRetryWhenReceiveFailed">
            <summary>
            May this Session be resent on a different connection because reading of the response did not succeed?
            </summary>
            <returns>TRUE if the entire session may be resent on a new connection</returns>
        </member>
        <member name="M:Fiddler.Session._handledAsAutomaticAuth">
            <summary>
            If the response demands credentials and the Session is configured to have Fiddler provide those
            credentials, try to do so now.
            </summary>
            <returns>TRUE if Fiddler has generated a response to an Auth challenge; FALSE otherwise.</returns>
        </member>
        <member name="M:Fiddler.Session._PerformInnerAuth">
            <summary>
            This method will perform obtain authentication credentials from System.NET using a reflection trick to grab the internal value.
            It's needed to cope with Channel-Binding-Tokens (CBT).
            
            This MUST live within its own non-inlined method such that when it's run on an outdated version of the .NET Framework, the outdated
            version of the target object triggers a TypeLoadException in such a way that the caller can catch it and warn the user without 
            killing Fiddler.exe.
            </summary>
            <returns>TRUE if we didn't hit any exceptions</returns>
        </member>
        <member name="M:Fiddler.Session.propagateProcessInfo(Fiddler.Session)">
            <summary>
            Copies process-owner information from a source session to a destination session. Used during handling of AutoRedirects
            and auto-Authentications
            </summary>
            <param name="sessionFrom"></param>
        </member>
        <member name="M:Fiddler.Session._GetSPNForUri(System.Uri)">
            <summary>
            Returns a Kerberos-usable SPN for the target
            http://dev.chromium.org/developers/design-documents/http-authentication
            "HttpAuthHandlerNegotiate::CreateSPN"
            http://blog.michelbarneveld.nl/michel/archive/2009/11/14/the-reason-why-kb911149-and-kb908209-are-not-the-soluton.aspx
            </summary>
            <param name="uriTarget"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Session.GetRedirectTargetURL">
            <summary>
            Returns the fully-qualified URL to which this Session's response points, or null.
            This method is needed because many servers (illegally) return a relative url in HTTP/3xx Location response headers.
            </summary>
            <returns>null, or Target URL. Note, you may want to call Utilities.TrimAfter(sTarget, '#'); on the response</returns>
        </member>
        <member name="M:Fiddler.Session.GetRedirectTargetURL(System.String,System.String)">
            <summary>
            Gets a redirect-target from a base URI and a Location header
            </summary>
            <param name="sBase"></param>
            <param name="sLocation"></param>
            <returns>null, or Target URL. Note, you may want to call Utilities.TrimAfter(sTarget, '#');</returns>
        </member>
        <member name="M:Fiddler.Session.isRedirectableURI(System.String,System.String,System.String@)">
            <summary>
            Fiddler can only auto-follow redirects to HTTP/HTTPS/FTP.
            </summary>
            <param name="sBase">The BASE URL to which a relative redirection should be applied</param>
            <param name="sLocation">Response "Location" header</param>
            <returns>TRUE if the auto-redirect target is allowed</returns>
        </member>
        <member name="M:Fiddler.Session._handledAsAutomaticRedirect">
            <summary>
            Handles a Response's Redirect if the Session is configured to do so.
            </summary>
            <returns>TRUE if a redirect was handled, FALSE otherwise</returns>
        </member>
        <member name="M:Fiddler.Session.ExecuteHTTPLintOnResponse">
            <summary>
            Check for common mistakes in HTTP Responses and notify the user if they are found. Called only if Linting is enabled.
            </summary>
        </member>
        <member name="M:Fiddler.Session._AssignID">
            <summary>
            Assign a Session ID. Called by ClientChatter when headers are available
            </summary>
        </member>
        <member name="M:Fiddler.Session._executeObtainRequest">
            <summary>
            Called only by InnerExecute, this method reads a request from the client and performs tampering/manipulation on it.
            </summary>
            <returns>TRUE if there's a Request object and we should continue processing. FALSE if reading the request failed
            *OR* if script or an extension changed the session's State to DONE or ABORTED.
            </returns>
        </member>
        <member name="M:Fiddler.Session._HandleFailedReadRequest">
            <summary>
            If the executeObtainRequest called failed, we perform cleanup
            </summary>
        </member>
        <member name="M:Fiddler.Session._isResponseMultiStageAuthChallenge">
            <summary>
            Returns TRUE if response is a NTLM or NEGO challenge
            </summary>
            <returns>True for HTTP/401,407 with NEGO or NTLM demand</returns>
        </member>
        <member name="M:Fiddler.Session._isResponseAuthChallenge">
            <summary>
            Returns TRUE if response is a Digest, NTLM, or Nego challenge
            </summary>
            <returns>True for HTTP/401,407 with Digest, NEGO, NTLM demand</returns>
        </member>
        <member name="M:Fiddler.Session._replaceVirtualHostnames">
            <summary>
            Replace the "ipv*.fiddler "fake" hostnames with the IP-literal equvalents.
            </summary>
        </member>
        <member name="M:Fiddler.Session._isDirectRequestToFiddler">
            <summary>
            Determines if request host is pointing directly at Fiddler.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Session._returnEchoServiceResponse">
            <summary>
            Echo the client's request back as a HTTP Response, encoding to prevent XSS.
            </summary>
        </member>
        <member name="M:Fiddler.Session._returnPACFileResponse">
            <summary>
            Send a Proxy Configuration script back to the client.
            </summary>
        </member>
        <member name="M:Fiddler.Session._returnUpstreamPACFileResponse">
            <summary>
            Send a Proxy Configuration script back to WinHTTP, so that Fiddler can use an upstream proxy specified
            by a script on a fileshare. (WinHTTP only allows HTTP/HTTPS-hosted script files)
            </summary>
        </member>
        <member name="M:Fiddler.Session._returnRootCert(Fiddler.Session)">
            <summary>
            Send the Fiddler Root certificate back to the client
            </summary>
        </member>
        <member name="M:Fiddler.Session._ReturnSelfGeneratedCONNECTTunnel(System.String)">
             <summary>
             This method indicates to the client that a secure tunnel was created,
             without actually talking to an upstream server.
             
             If Fiddler's AutoResponder is enabled, and that autoresponder denies passthrough,
             then Fiddler itself will always indicate "200 Connection Established" and wait for
             another request from the client. That subsequent request can then potentially be 
             handled by the AutoResponder engine.
            
             BUG BUG: This occurs even if Fiddler isn't configured for HTTPS Decryption
             
             </summary>
             <param name="sHostname">The hostname to use in the Certificate returned to the client</param>
        </member>
        <member name="M:Fiddler.Session._isNTLMType2">
            <summary>
            This method adds a Proxy-Support: Session-Based-Authentication header and indicates whether the response is Nego:Type2.
            </summary>
            <returns>Returns TRUE if server returned a credible Type2 NTLM Message</returns>
        </member>
        <member name="M:Fiddler.Session._MayReuseMyClientPipe">
            <summary>
            This helper evaluates the conditions for client socket reuse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Session.ReturnResponse(System.Boolean)">
            <summary>
            Sends the Response that Fiddler received from the server back to the client socket.
            </summary>
            <param name="bForceClientServerPipeAffinity">Should the client and server pipes be tightly-bound together?</param>
            <returns>True, if the response was successfully sent to the client</returns>
        </member>
        <member name="M:Fiddler.Session._createNextSession(System.Boolean)">
            <summary>
            Sets up the next Session on these pipes, binding this Session's pipes to that new Session, as appropriate. When this method is called,
            the nextSession variable is populated with the new Session, and that object is executed at the appropriate time.
            </summary>
            <param name="bForceClientServerPipeAffinity">TRUE if both the client and server pipes should be bound regardless of the serverPipe's ReusePolicy</param>
        </member>
        <member name="P:Fiddler.Session.BitFlags">
            <summary>
            Bitflags of commonly-queried session attributes
            </summary>
        </member>
        <member name="P:Fiddler.Session.isTunnel">
            <summary>
            Returns True if this is a HTTP CONNECT tunnel.
            </summary>
        </member>
        <member name="P:Fiddler.Session.Tag">
            <summary>
            A common use for the Tag property is to store data that is closely associated with the Session.
            It is NOT marshalled during drag/drop and is NOT serialized to a SAZ file.
            </summary>
        </member>
        <member name="E:Fiddler.Session.OnStateChanged">
            <summary>
            This event fires at any time the session's State changes. Use with caution due to the potential for performance impact.
            </summary>
        </member>
        <member name="E:Fiddler.Session.OnContinueTransaction">
            <summary>
            This event fires if this Session automatically yields a new one, for instance, if Fiddler is configured to automatically
            follow redirects or perform multi-leg authentication (X-AutoAuth).
            </summary>
        </member>
        <member name="P:Fiddler.Session.TunnelIsOpen">
            <summary>
            If this session is a Tunnel, and the tunnel's IsOpen property is TRUE, returns TRUE. Otherwise returns FALSE.
            </summary>
        </member>
        <member name="P:Fiddler.Session.TunnelIngressByteCount">
            <summary>
            If this session is a Tunnel, returns number of bytes sent from the Server to the Client
            </summary>
        </member>
        <member name="P:Fiddler.Session.TunnelEgressByteCount">
            <summary>
            If this session is a Tunnel, returns number of bytes sent from the Client to the Server
            </summary>
        </member>
        <member name="P:Fiddler.Session.RequestBody">
            <summary>
            Gets or Sets the HTTP Request body bytes. 
            Setter adjusts Content-Length header, and removes Transfer-Encoding and Content-Encoding headers.
            Setter DOES NOT CLONE the passed array.
            Setter will throw if the Request object does not exist for some reason.
            Use utilSetRequestBody(sStr) to ensure proper character encoding if you need to use a string.
            </summary>
        </member>
        <member name="P:Fiddler.Session.ResponseBody">
            <summary>
            Gets or Sets the HTTP Response body bytes.
            Setter adjusts Content-Length header, and removes Transfer-Encoding and Content-Encoding headers.
            Setter DOES NOT CLONE the passed array.
            Setter will throw if the Response object has not yet been created. (See utilCreateResponseAndBypassServer)
            Use utilSetResponseBody(sStr) to ensure proper character encoding if you need to use a string.
            </summary>
        </member>
        <member name="P:Fiddler.Session.isHTTPS">
            <summary>
            When true, this session was conducted using the HTTPS protocol.
            </summary>
        </member>
        <member name="P:Fiddler.Session.isFTP">
            <summary>
            When true, this session was conducted using the FTP protocol.
            </summary>
        </member>
        <member name="P:Fiddler.Session.LocalProcessID">
            <summary>
            Get the process ID of the application which made this request, or 0 if it cannot be determined.
            </summary>
        </member>
        <member name="P:Fiddler.Session.LocalProcess">
            <summary>
            Get the Process Info of the application which made this request, or String.Empty if it is not known
            </summary>
        </member>
        <member name="P:Fiddler.Session.SuggestedFilename">
            <summary>
            Gets a path-less filename suitable for saving the Response entity. Uses Content-Disposition if available.
            </summary>
        </member>
        <member name="P:Fiddler.Session.bypassGateway">
            <summary>
            Set to true in OnBeforeRequest if this request should bypass the gateway
            </summary>
        </member>
        <member name="P:Fiddler.Session.clientPort">
            <summary>
            Returns the port used by the client to communicate to Fiddler.
            </summary>
        </member>
        <member name="P:Fiddler.Session.state">
            <summary>
            State of session. Note Side-Effects: If setting to .Aborted, calls FinishUISession. If setting to/from a Tamper state, calls RefreshMyInspectors
            </summary>
        </member>
        <member name="P:Fiddler.Session.PathAndQuery">
            <summary>
            Returns the path and query part of the URL. (For a CONNECT request, returns the host:port to be connected.)
            </summary>
        </member>
        <member name="P:Fiddler.Session.fullUrl">
            <summary>
            Retrieves the complete URI, including protocol/scheme, in the form http://www.host.com/filepath?query.
            Or sets the complete URI, adjusting the UriScheme and/or Host.
            </summary>
        </member>
        <member name="P:Fiddler.Session.url">
            <summary>
            Gets or sets the URL (without protocol) being requested from the server, in the form www.host.com/filepath?query.
            </summary>
        </member>
        <member name="P:Fiddler.Session.host">
            <summary>
            DNS Name of the host server targeted by this request. May include IPv6 literal brackets. NB: a port# may be included.
            </summary>
        </member>
        <member name="P:Fiddler.Session.hostname">
            <summary>
            DNS Name of the host server (no port) targeted by this request. Will include IPv6-literal brackets for IPv6-literal addresses
            </summary>
        </member>
        <member name="P:Fiddler.Session.port">
            <summary>
            Returns the server port to which this request is targeted.
            </summary>
        </member>
        <member name="P:Fiddler.Session.id">
            <summary>
            Returns the sequential number of this session. Note, by default numbering is restarted at zero when the session list is cleared.
            </summary>
        </member>
        <member name="P:Fiddler.Session.clientIP">
            <summary>
            Returns the Address used by the client to communicate to Fiddler.
            </summary>
        </member>
        <member name="P:Fiddler.Session.responseCode">
            <summary>
            Gets or Sets the HTTP Status code of the server's response
            </summary>
        </member>
        <member name="P:Fiddler.Session.bHasWebSocketMessages">
            <summary>
            Checks whether this is a WebSocket, and if so, whether it has logged any parsed messages.
            </summary>
        </member>
        <member name="P:Fiddler.Session.bHasResponse">
            <summary>
            Returns TRUE if this session's State &gt; ReadingResponse, and oResponse, oResponse.headers, and responseBodyBytes are all non-null. Note that
            bHasResponse returns FALSE if the session is currently reading, even if a body was copied using the COMETPeek feature
            </summary>
        </member>
        <member name="P:Fiddler.Session.Item(System.String,System.String)">
            <summary>
            Indexer property into SESSION flags, REQUEST headers, and RESPONSE headers. e.g. oSession["Request", "Host"] returns string value for the Request host header. If null, returns String.Empty
            </summary>
            <param name="sCollection">SESSION, REQUEST or RESPONSE</param>
            <param name="sName">The name of the flag or header</param>
            <returns>String value or String.Empty</returns>
        </member>
        <member name="P:Fiddler.Session.Item(System.String)">
            <summary>
            Simple indexer into the Session's oFlags object; returns null if flag is not present.
            </summary>
            <returns>
            Returns the string value if the specified flag is present, or null if it is not.
            </returns>
        </member>
        <member name="T:Fiddler.SessionData">
            <summary>
            This object holds Session information as a set of four easily-marshalled byte arrays.
            It is serializable, which enables  cross-process transfer of this data (as in a drag/drop operation).
            (Internally, data is serialized as if it were being stored in a SAZ file)
            </summary>
        </member>
        <member name="M:Fiddler.SessionData.#ctor(Fiddler.Session)">
            <summary>
            Create a SessionData object. 
            Note: Method must run as cheaply as possible, since it runs on all Drag/Dropped sessions within Fiddler itself.
            </summary>
            <param name="oS"></param>
        </member>
        <member name="T:Fiddler.ProxyExecuteParams">
            <summary>
            Parameters passed into the AcceptConnection method.
            </summary>
        </member>
        <member name="F:Fiddler.ProxyExecuteParams.oSocket">
            <summary>
            The Socket which represents the newly-accepted Connection
            </summary>
        </member>
        <member name="F:Fiddler.ProxyExecuteParams.oServerCert">
            <summary>
            The Certificate to pass to SecureClientPipeDirect immediately after accepting the connection.
            Normally null, this will be set if the proxy endpoint is configured as a "Secure" endpoint
            by AssignEndpointCertificate / ActAsHTTPSEndpointForHostname.
            </summary>
        </member>
        <member name="F:Fiddler.ProxyExecuteParams.dtConnectionAccepted">
            <summary>
            The DateTime of Creation of this connection
            </summary>
        </member>
        <member name="F:Fiddler.ContinueTransactionReason.None">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Fiddler.ContinueTransactionReason.Authenticate">
            <summary>
            The new Session is needed to respond to an Authentication Challenge
            </summary>
        </member>
        <member name="F:Fiddler.ContinueTransactionReason.Redirect">
            <summary>
            The new Session is needed to follow a Redirection
            </summary>
        </member>
        <member name="F:Fiddler.ContinueTransactionReason.Tunnel">
            <summary>
            The new Session is needed to generate a CONNECT tunnel
            </summary>
        </member>
        <member name="T:Fiddler.StateChangeEventArgs">
            <summary>
            Event arguments constructed for the OnStateChanged event raised when a Session's state property changed
            </summary>
        </member>
        <member name="F:Fiddler.StateChangeEventArgs.oldState">
            <summary>
            The prior state of this session
            </summary>
        </member>
        <member name="F:Fiddler.StateChangeEventArgs.newState">
            <summary>
            The new state of this session
            </summary>
        </member>
        <member name="M:Fiddler.StateChangeEventArgs.#ctor(Fiddler.SessionStates,Fiddler.SessionStates)">
            <summary>
            Constructor for the change in state
            </summary>
            <param name="ssOld">The old state</param>
            <param name="ssNew">The new state</param>
        </member>
        <member name="T:Fiddler.ProcessingStates">
            <summary>
            States for the (future) Session-processing State Machine.
            
            Fun Idea: We can omit irrelevant states from FiddlerCore and thus not have to litter
            our state machine itself with a bunch of #if FIDDLERCORE checks...
            ... except no, that doesn't work because compiler still cares. Rats.
            
            </summary>
        </member>
        <member name="T:Fiddler.SessionStates">
            <summary>
            State of the current session
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.Created">
            <summary>
            Object created but nothing's happening yet
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.ReadingRequest">
            <summary>
            Thread is reading the HTTP Request
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.AutoTamperRequestBefore">
            <summary>
            AutoTamperRequest pass 1	 (IAutoTamper,  OnBeforeRequest script method)
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.HandTamperRequest">
            <summary>
            User can tamper using Fiddler Inspectors
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.AutoTamperRequestAfter">
            <summary>
            AutoTamperRequest pass 2	 (Only used by IAutoTamper)
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.SendingRequest">
            <summary>
            Thread is sending the Request to the server
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.ReadingResponse">
            <summary>
            Thread is reading the HTTP Response
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.AutoTamperResponseBefore">
            <summary>
            AutoTamperResponse pass 1 (Only used by IAutoTamper)
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.HandTamperResponse">
            <summary>
            User can tamper using Fiddler Inspectors
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.AutoTamperResponseAfter">
            <summary>
            AutoTamperResponse pass 2 (Only used by IAutoTamper)
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.SendingResponse">
            <summary>
            Sending response to client application
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.Done">
            <summary>
            Session complete
            </summary>
        </member>
        <member name="F:Fiddler.SessionStates.Aborted">
            <summary>
            Session was aborted (client didn't want response, fatal error, etc)
            </summary>
        </member>
        <member name="T:Fiddler.SessionFlags">
            <summary>
            This enumeration provides the values for the Session object's BitFlags field
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.None">
            <summary>
            No flags are set
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.IsHTTPS">
            <summary>
            The request originally arrived with a URL specifying the HTTPS protocol.
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.IsFTP">
            <summary>
            The request originally arrived with a URL specifying the FTP protocol.
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.Ignored">
            <summary>
            Ignore this traffic; do not buffer, store, or call event handlers
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ClientPipeReused">
            <summary>
            The client pipe was reused
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ServerPipeReused">
            <summary>
            The server pipe was reused
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.RequestStreamed">
            <summary>
            The request was transmitted to the server when its headers were complete
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ResponseStreamed">
            <summary>
            The response was streamed
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.RequestGeneratedByFiddler">
            <summary>
            The request was generated by Fiddler itself (e.g. the Composer tab)
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ResponseGeneratedByFiddler">
            <summary>
            The response was generated by Fiddler itself (e.g. AutoResponder or utilCreateResponseAndBypassServer)
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.LoadedFromSAZ">
            <summary>
            This session was loaded from a .SAZ File
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ImportedFromOtherTool">
            <summary>
             This session was loaded from some other tool
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.SentToGateway">
            <summary>
            This request was sent to an upstream (CERN) gateway proxy
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.IsBlindTunnel">
            <summary>
            This is a "blind" CONNECT tunnel for HTTPS traffic 
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.IsDecryptingTunnel">
            <summary>
            This is a CONNECT tunnel which decrypts HTTPS traffic as it flows through
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ServedFromCache">
            <summary>
            This response was served from a client cache, bypassing Fiddler. Fiddler only "sees" this session because other software reported it to Fiddler
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ProtocolViolationInRequest">
            <summary>
            There was a HTTP Protocol violation in the client's request
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ProtocolViolationInResponse">
            <summary>
            There was a HTTP Protocol violation in the server's response
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.ResponseBodyDropped">
            <summary>
            Response body was dropped, e.g due to fiddler.network.streaming.ForgetStreamedData or log-drop-response-body flag
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.IsWebSocketTunnel">
            <summary>
            This is a CONNECT tunnel for WebSocket traffic
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.SentToSOCKSGateway">
            <summary>
            This request was sent using the SOCKS protocol
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.RequestBodyDropped">
            <summary>
            Request body was dropped, e.g due to log-drop-request-body flag
            </summary>
        </member>
        <member name="F:Fiddler.SessionFlags.IsRPCTunnel">
            <summary>
            The request was to create a RPC tunnel (e.g. on an RPC_OUT_DATA request)
            </summary>
        </member>
        <member name="T:Fiddler.SessionTimers">
            <summary>
            A SessionTimers object holds timing information about a single Session.
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ClientConnected">
            <summary>
            The time at which the client's HTTP connection to Fiddler was established
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ClientBeginRequest">
            <summary>
            The time at which the request's first Send() to Fiddler completes
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.FiddlerGotRequestHeaders">
            <summary>
            The time at which the request headers were received
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ClientDoneRequest">
            <summary>
            The time at which the request to Fiddler completes (aka RequestLastWrite)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ServerConnected">
            <summary>
            The time at which the server connection has been established
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.FiddlerBeginRequest">
            <summary>
            The time at which Fiddler begins sending the HTTP request to the server (FiddlerRequestFirstSend)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ServerGotRequest">
            <summary>
            The time at which Fiddler has completed sending the HTTP request to the server (FiddlerRequestLastSend).
            BUG: Should be named "FiddlerEndRequest". 
            NOTE: Value here is often misleading due to buffering inside WinSock's send() call.
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ServerBeginResponse">
            <summary>
            The time at which Fiddler receives the first byte of the server's response (ServerResponseFirstRead)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.FiddlerGotResponseHeaders">
            <summary>
            The time at which Fiddler received the server's headers
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ServerDoneResponse">
            <summary>
            The time at which Fiddler has completed receipt of the server's response (ServerResponseLastRead)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ClientBeginResponse">
            <summary>
            The time at which Fiddler has begun sending the Response to the client (ClientResponseFirstSend)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.ClientDoneResponse">
            <summary>
            The time at which Fiddler has completed sending the Response to the client (ClientResponseLastSend)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.GatewayDeterminationTime">
            <summary>
            The number of milliseconds spent determining which gateway should be used to handle this request
            (Should be mutually exclusive to DNSTime!=0)
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.DNSTime">
            <summary>
            The number of milliseconds spent waiting for DNS
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.TCPConnectTime">
            <summary>
            The number of milliseconds spent waiting for the server TCP/IP connection establishment
            </summary>
        </member>
        <member name="F:Fiddler.SessionTimers.HTTPSHandshakeTime">
            <summary>
            The number of milliseconds elapsed while performing the HTTPS handshake with the server
            </summary>
        </member>
        <member name="M:Fiddler.SessionTimers.ToString">
            <summary>
            Override of ToString shows timer info in a fancy format
            </summary>
            <returns>Timing information as a string</returns>
        </member>
        <member name="M:Fiddler.SessionTimers.ToString(System.Boolean)">
            <summary>
            Override of ToString shows timer info in a fancy format
            </summary>
            <param name="bMultiLine">TRUE if the result can contain linebreaks; false if comma-delimited format preferred</param>
            <returns>Timing information as a string</returns>
        </member>
        <member name="P:Fiddler.SessionTimers.EnableHighResolutionTimers">
            <summary>
            Enables High-Resolution timers, which are bad for battery-life but good for the accuracy of timestamps.
            See http://technet.microsoft.com/en-us/sysinternals/bb897568 for the ClockRes utility that shows current clock resolution.
            NB: Exiting Fiddler reverts this to the default value.
            </summary>
        </member>
        <member name="M:Fiddler.SessionTimers.NetTimestamps.AddRead(System.Int64,System.Int32)">
            <summary>
            Log a Read's size and timestamp
            </summary>
            <param name="tsRead">Number of milliseconds since first calling .Read()</param>
            <param name="bytesRead">Number of bytes returned in this read</param>
        </member>
        <member name="M:Fiddler.SessionTimers.NetTimestamps.ToFoldedArray(System.Int32)">
            <summary>
            Return the ReadTimings as an array. Only one read is counted per millisecond
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.SessionTimers.NetTimestamps.FromCopy(Fiddler.SessionTimers.NetTimestamps)">
            <summary>
            Create a new List and append to it
            </summary>
            <param name="oExistingTS"></param>
            <returns></returns>
        </member>
        <member name="T:Fiddler.URLMonInterop">
            <summary>
            URLMon Interop Class
            </summary>
        </member>
        <member name="M:Fiddler.URLMonInterop.SetUAStringInProcess(System.String)">
            <summary>
            Set the user-agent string for the current process
            </summary>
            <param name="sUA">New UA string</param>
        </member>
        <member name="M:Fiddler.URLMonInterop.GetProxyInProcess">
            <summary>
            Query WinINET for the current process' proxy settings. Oddly, there's no way to UrlMkGetSessionOption for the current proxy.
            </summary>
            <returns>String of hex suitable for display</returns>
        </member>
        <member name="M:Fiddler.URLMonInterop.ResetProxyInProcessToDefault">
            <summary>
            Configures the current process to use the system proxy for URLMon/WinINET traffic.
            </summary>
        </member>
        <member name="M:Fiddler.URLMonInterop.SetProxyDisabledForProcess">
            <summary>
            Configures the current process to use no Proxy for URLMon/WinINET traffic.
            </summary>
        </member>
        <member name="M:Fiddler.URLMonInterop.SetProxyInProcess(System.String,System.String)">
            <summary>
            Sets the proxy for the current process to the specified list. See http://msdn.microsoft.com/en-us/library/aa383996(VS.85).aspx
            </summary>
            <param name="sProxy">e.g. "127.0.0.1:8888" or "http=insecProxy:80;https=secProxy:444"</param>
            <param name="sBypassList">Semi-colon delimted list of hosts to bypass proxy; use &lt;local&gt; to bypass for Intranet</param>
        </member>
        <member name="T:Fiddler.Utilities">
            <summary>
            Holds a variety of useful functions used in Fiddler and its addons. 
            </summary>
        </member>
        <member name="M:Fiddler.Utilities.WriteSessionArchive(System.String,Fiddler.Session[],System.String,System.Boolean)">
            <summary>
            Create a Session Archive Zip file containing the specified sessions
            </summary>
            <param name="sFilename">The filename of the SAZ file to store</param>
            <param name="arrSessions">Array of sessions to store</param>
            <param name="sPassword">Password to encrypt the file with, or null</param>
            <param name="bVerboseDialogs">TRUE if verbose error dialogs should be shown.</param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.WriteSessionToSAZ(Fiddler.Session,Fiddler.ISAZWriter,System.Int32,System.String,System.Text.StringBuilder,System.Boolean)">
            <summary>
            This is a refactored helper function which writes a single session to an open SAZ file.
            </summary>
            <param name="oSession">The session to write to the file</param>
            <param name="odfZip">The ZIP File</param>
            <param name="iFileNumber">The number of this file</param>
            <param name="sFileNumberFormat">The format string (e.g. "D3") to use when formatting the file number</param>
            <param name="sbHTML">The HTML String builder to write index information</param>
            <param name="bVerboseDialogs">TRUE to show verbose error dialog information</param>
        </member>
        <member name="M:Fiddler.Utilities.ReadSessionArchive(System.String,System.Boolean,System.String)">
            <summary>
            Reads a Session Archive Zip file into an array of Session objects
            </summary>
            <param name="sFilename">Filename to load</param>
            <param name="bVerboseDialogs"></param>
            <returns>Loaded array of sessions or null, in case of failure</returns>
        </member>
        <member name="M:Fiddler.Utilities.ReadSessionArchive(System.String,System.Boolean,System.String,Fiddler.GetPasswordDelegate)">
            <summary>
            Reads a Session Archive Zip file into an array of Session objects
            </summary>
            <param name="sFilename">Filename to load</param>
            <param name="bVerboseDialogs"></param>
            <returns>Loaded array of sessions or null, in case of failure</returns>
        </member>
        <member name="M:Fiddler.Utilities.EnsureInRange``1(``0,``0,``0)">
            <summary>
            Ensures a value is within a specified range.
            </summary>
            <typeparam name="T">Type of the value</typeparam>
            <param name="current">Current value</param>
            <param name="min">Min value</param>
            <param name="max">Max value</param>
            <returns>Returns the provided value, unless it is outside of the specified range, in which case the nearest "fencepost" is returned.</returns>
        </member>
        <member name="F:Fiddler.Utilities.emptyByteArray">
            <summary>
            A static byte array containing 0 elements. Use to avoid having many copies of an empty byte[] floating around.
            </summary>
        </member>
        <member name="M:Fiddler.Utilities.ObtainSaveFilename(System.String,System.String)">
            <summary>
            Queries the user for a filename
            </summary>
            <param name="sDialogTitle">Dialog title</param>
            <param name="sFilter">String representing file dialog filter</param>
            <returns>Filename or null</returns>
        </member>
        <member name="M:Fiddler.Utilities.ObtainSaveFilename(System.String,System.String,System.String)">
            <summary>
            Queries the user for a filename
            </summary>
            <param name="sDialogTitle">Dialog title</param>
            <param name="sFilter">String representing file dialog filter</param>
            <param name="sInitialDirectory">Initial directory or null</param>
            <returns>Filename or null</returns>
        </member>
        <member name="M:Fiddler.Utilities.AddPathToPlaces(System.Windows.Forms.FileDialog,System.String)">
            <summary>
            Adds a place to a FileDialog's "Places" collection.
            Includes error handling for internal .NET Framework bug.
            
            Note: CustomPlaces requires SP2 of .NET Framework v2. Attempting to call this method will throw System.MissingMethodException 
            if the required service pack is not installed.
            </summary>
            <param name="dlg"></param>
            <param name="sPath"></param>
        </member>
        <member name="M:Fiddler.Utilities.ObtainOpenFilename(System.String,System.String)">
            <summary>
            Queries the user for an OPEN filename
            </summary>
            <param name="sDialogTitle">Dialog title</param>
            <param name="sFilter">String representing file dialog filter (e.g. "All files (*.*)|*.*")</param>
            <returns>Filename or null</returns>
        </member>
        <member name="M:Fiddler.Utilities.ObtainOpenFilename(System.String,System.String,System.String)">
            <summary>
            Queries the user for an OPEN filename
            </summary>
            <param name="sDialogTitle">Dialog title</param>
            <param name="sFilter">String representing file dialog filter</param>
            <param name="sInitialDirectory">Initial directory or null</param>
            <returns>Filename or null</returns>
        </member>
        <member name="M:Fiddler.Utilities.FiddlerMeetsVersionRequirement(System.Reflection.Assembly,System.String)">
            <summary>
            Check to see that the target assembly defines a RequiredVersionAttribute and that the current Fiddler instance meets that requirement
            </summary>
            <param name="assemblyInput">The assembly to test</param>
            <param name="sWhatType">The "type" of extension for display in error message</param>
            <returns>TRUE if the assembly includes a requirement and Fiddler meets it.</returns>
        </member>
        <member name="M:Fiddler.Utilities.CompareVersions(System.String,System.Version)">
            <summary>
            Typically, a version number is displayed as "major number.minor number.build number.private part number". 
            </summary>
            <param name="sRequiredVersion">Version required</param>
            <param name="verTest">Version of the binary being tested</param>
            <returns>Returns 0 if exact match, else greater than 0 if Required version greater than verTest</returns>
        </member>
        <member name="M:Fiddler.Utilities.CompactPath(System.String,System.Int32)">
            <summary>
            Shrinks a path string to fit within a certain number of characters, replacing segments with ellipses if needed.
            </summary>
            <param name="sPath">The Path to compact</param>
            <param name="iCharLen">Number of characters to shrink to</param>
            <returns>The compacted string, or the original string if compaction wasn't needed or failed</returns>
        </member>
        <member name="M:Fiddler.Utilities.CollapsePath(System.String)">
            <summary>
            Convert a full path into one that uses environment variables
            </summary>
            <param name="sPath">e.g. C:\windows\system32\foo.dll</param>
            <returns>%WINDIR%\System32\foo.dll</returns>
        </member>
        <member name="M:Fiddler.Utilities.EnsureValidAsPath(System.String)">
            <summary>
            Address the problem where the target "PATH" calls for a directoryname is already a filename
            </summary>
            <param name="sTargetFolder"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.EnsureUniqueFilename(System.String)">
            <summary>
            Ensure that the target file does not yet exist. If it does, generates a new filename with an embedded identifier, e.g. out[1].txt instead.
            Attempts to ensure filename is creatable; e.g. if a path component needs to be a directory but is a file already, injects [#] into that 
            path component.
            </summary>
            <param name="sFilename">Candidate filename</param>
            <returns>New filename which does not yet exist</returns>
        </member>
        <member name="M:Fiddler.Utilities.EnsureOverwritable(System.String)">
            <summary>
            Ensure that the target path exists and if a file exists there, it is not readonly or hidden.
            WARNING: Can throw if target "Filename" calls for a parent directoryname that is already used as a filename by a non-directory.
            E.g. EnsureOverwriteable(C:\io.sys\filename.txt); would throw.
            </summary>
            <param name="sFilename">The candidate filename</param>
        </member>
        <member name="M:Fiddler.Utilities.WriteArrayToFile(System.String,System.Byte[])">
            <summary>
            Writes arrBytes to a file, creating the target directory and overwriting if the file exists.
            </summary>
            <param name="sFilename">Path to File to write.</param>
            <param name="arrBytes">Bytes to write.</param>
        </member>
        <member name="M:Fiddler.Utilities.ReadEntireStream(System.IO.Stream,System.Byte[])">
            <summary>
            Fills an array completely using the provided stream. Unlike a normal .Read(), this one will always fully fill the array unless the Stream throws.
            </summary>
            <param name="oStream">The stream from which to read.</param>
            <param name="arrBytes">The byte array into which the data should be stored.</param>
            <returns>The count of bytes read.</returns>
        </member>
        <member name="M:Fiddler.Utilities.JoinByteArrays(System.Byte[],System.Byte[])">
            <summary>
            Create a new byte[] containing the contents of two other byte arrays.
            </summary>
            <param name="arr1"></param>
            <param name="arr2"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.GetCommaTokenValue(System.String,System.String)">
            <summary>
            Returns the Value from a (case-insensitive) token in the header string. Correctly handles double-quoted strings.
            Allows comma and semicolon as delimiter. Trailing whitespace may be present.
            </summary>
            <param name="sString">Name of the header</param>
            <param name="sTokenName">Name of the token</param>
            <returns>Value of the token if present; otherwise, null</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimTo(System.String,System.Int32)">
            <summary>
            Ensures that the target string is iMaxLength or fewer characters
            </summary>
            <param name="sString">The string to trim from</param>
            <param name="iMaxLength">The maximum number of characters to return</param>
            <returns>Up to iMaxLength characters from the "Head" of the string.</returns>
        </member>
        <member name="M:Fiddler.Utilities.EllipsizeIfNeeded(System.String,System.Int32)">
            <summary>
            Ensures that the target string is iMaxLength or fewer characters, appending ... if truncation occurred
            </summary>
            <param name="sString">The string to trim from</param>
            <param name="iMaxLength">The maximum number of characters to return</param>
            <returns>The string, or up to iMaxLength-1 characters from the "Head" of the string, with \u2026 appeneded.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimAfter(System.String,System.String)">
            <summary>
            Returns the "Head" of a string, before and not including a specified search string.
            </summary>
            <param name="sString">The string to trim from</param>
            <param name="sDelim">The delimiting string at which the trim should end.</param>
            <returns>Part of a string up to (but not including) sDelim, or the full string if sDelim was not found.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimAfter(System.String,System.Char)">
            <summary>
            Returns the "Head" of a string, before and not including the first instance of specified delimiter.
            </summary>
            <param name="sString">The string to trim from.</param>
            <param name="chDelim">The delimiting character at which the trim should end.</param>	
            <returns>Part of a string up to (but not including) chDelim, or the full string if chDelim was not found.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimAfter(System.String,System.Int32)">
            <summary>
            [Deprecated] Ensures that the target string is iMaxLength or fewer characters
            </summary>
            <param name="sString">The string to trim from</param>
            <param name="iMaxLength">The maximum number of characters to return</param>
            <remarks>Identical to the <see cref="M:Fiddler.Utilities.TrimTo(System.String,System.Int32)"/> method.</remarks>
            <returns>Up to iMaxLength characters from the "Head" of the string.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimBefore(System.String,System.Char)">
            <summary>
            Returns the "Tail" of a string, after (but NOT including) the First instance of specified delimiter.
            See also <seealso cref="M:Fiddler.Utilities.TrimBeforeLast(System.String,System.Char)"/>
            </summary>
            <param name="sString">The string to trim from.</param>
            <param name="chDelim">The delimiting character after which the text should be returned.</param>
            <returns>Part of a string after (but not including) chDelim, or the full string if chDelim was not found.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimBefore(System.String,System.String)">
            <summary>
            Returns the "Tail" of a string, after (but NOT including) the First instance of specified search string.     
            <seealso cref="M:Fiddler.Utilities.TrimBeforeLast(System.String,System.String)"/>
            </summary>
            <param name="sString">The string to trim from.</param>
            <param name="sDelim">The delimiting string after which the text should be returned.</param>
            <returns>Part of a string after (but not including) sDelim, or the full string if sDelim was not found.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimUpTo(System.String,System.String)">
            <summary>
            Returns the "Tail" of a string, after (and including) the first instance of specified search string.      
            </summary>
            <param name="sString">The string to trim from.</param>
            <param name="sDelim">The delimiting string at which the text should be returned.</param>
            <returns>Part of the string starting with sDelim, or the entire string if sDelim not found.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimBeforeLast(System.String,System.Char)">
            <summary>
            Returns the "Tail" of a string, after (but not including) the Last instance of specified delimiter.
            <seealso cref="M:Fiddler.Utilities.TrimBefore(System.String,System.Char)"/>
            </summary>
            <param name="sString">The string to trim from.</param>
            <param name="chDelim">The delimiting character after which text should be returned.</param>
            <returns>Part of a string after (but not including) the final chDelim, or the full string if chDelim was not found.</returns>
        </member>
        <member name="M:Fiddler.Utilities.TrimBeforeLast(System.String,System.String)">
            <summary>
            Returns the "Tail" of a string, after (but not including) the Last instance of specified substring.
            <seealso cref="M:Fiddler.Utilities.TrimBefore(System.String,System.String)"/>
            </summary>
            <param name="sString">The string to trim from.</param>
            <param name="sDelim">The delimiting string after which text should be returned.</param>
            <returns>Part of a string after (but not including) the final sDelim, or the full string if sDelim was not found.</returns>     
        </member>
        <member name="M:Fiddler.Utilities.StripIPv6LiteralBrackets(System.String)">
            <summary>
            Strip any IPv6-Literal brackets, needed when creating a Certificate
            </summary>
            <param name="sCertCN"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.HTTPMethodRequiresBody(System.String)">
            <summary>
            Determines true if a request with the specified HTTP Method/Verb MUST contain a entity body
            </summary>
            <param name="sMethod">The Method/Verb</param>
            <returns>TRUE if the HTTP Method MUST contain a request body.</returns>
        </member>
        <member name="M:Fiddler.Utilities.HTTPMethodIsIdempotent(System.String)">
            <summary>
            http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-26#section-4.2.2
            </summary>
            <param name="sMethod">HTTPMethod</param>
            <returns>TRUE if the method is deemed idempotent</returns>
        </member>
        <member name="M:Fiddler.Utilities.HTTPMethodAllowsBody(System.String)">
            <summary>
            Returns true if a request with the specified HTTP Method/Verb may contain a entity body
            </summary>
            <param name="sMethod">The Method/Verb</param>
            <returns>TRUE if the HTTP Method MAY contain a request body.</returns>
        </member>
        <member name="M:Fiddler.Utilities.HasImageFileExtension(System.String)">
            <summary>
            Detects whether string ends in a file extension generally recognized as an image file extension.
            Pass lowercase into this function.
            </summary>
            <param name="sExt">*Lowercase* string</param>
            <returns>TRUE if string ends with common image file extension</returns>
        </member>
        <member name="M:Fiddler.Utilities.IsBinaryMIME(System.String)">
            <summary>
            Determines if the specified MIME type is "binary" in nature.
            </summary>
            <param name="sContentType">The MIME type</param>
            <returns>TRUE if the MIME type is likely binary in nature</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetStringFromArrayRemovingBOM(System.Byte[],System.Text.Encoding)">
            <summary>
            Gets a string from a byte-array, stripping a Byte Order Marker preamble if present.
            </summary>
            <remarks>
            This function really shouldn't need to exist. Why doesn't calling .GetString on a string with a preamble remove the preamble???
            </remarks>
            <param name="arrInput">The byte array</param>
            <param name="oDefaultEncoding">The encoding to convert from *if* there's no Byte-order-marker</param>
            <returns>The string</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetTextEncoding(System.String)">
            <summary>
            WARNING: May throw.
            Gets an encoding, with proper respect for "utf8" as an alias for "utf-8"; Microsoft products don't support
            this prior to 2015-era, but it turns out to be common. We do have a linter elsewhere that reports a warning
            if it sees the dashless form.
            https://github.com/telerik/fiddler/issues/38
            </summary>
            <param name="sEncoding">Textual name of the encoding</param>
        </member>
        <member name="M:Fiddler.Utilities.getEntityBodyEncoding(Fiddler.HTTPHeaders,System.Byte[])">
            <summary>
            WARNING: Potentially slow.
            WARNING: Does not decode the HTTP Response body; if compressed, embedded META or _charset_ will not be checked
            Gets (via Headers or Sniff) the provided body's text Encoding. If not found, returns CONFIG.oHeaderEncoding (usually UTF-8).
            </summary>
            <param name="oHeaders">HTTP Headers, ideally containing a Content-Type header with a charset attribute.</param>
            <param name="oBody">byte[] containing the entity body.</param>
            <returns>A character encoding, if one could be determined</returns>
        </member>
        <member name="M:Fiddler.Utilities.getResponseBodyEncoding(Fiddler.Session)">
            <summary>
            Gets (via Headers or Sniff) the Response Text Encoding. Returns CONFIG.oHeaderEncoding (usually UTF-8) if unknown.
            Perf: May be quite slow; cache the response
            </summary>
            <param name="oSession">The session</param>
            <returns>The encoding of the response body</returns>
        </member>
        <member name="F:Fiddler.Utilities.sniffableEncodings">
            <summary>
            Set of encodings for which we'll attempt to sniff. (List order matters, I think)
            </summary>
        </member>
        <member name="M:Fiddler.Utilities.HtmlEncode(System.String)">
            <summary>
            HtmlEncode a string.
            In Fiddler itself, this is a simple wrapper for the System.Web.HtmlEncode function.
            The .NET3.5/4.0 Client Profile doesn't include System.Web, so we must provide our
            own implementation of HtmlEncode for FiddlerCore's use.
            </summary>
            <param name="sInput">String to encode</param>
            <returns>String encoded according to the rules of HTML Encoding, or null.</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetUTF8HexString(System.String,System.Int32@)">
            <summary>
            This function accepts a string and an offset into the string. It reads one or more %XX sequences from the
            string converting them into a UTF-8 string based on the input text
            </summary>
            <param name="sInput"></param>
            <param name="iX"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.UrlDecode(System.String)">
            <summary>
            Convert the %-encoded string into a string, interpreting %-escape sequences as UTF-8 characters
            </summary>
            <param name="sInput">%-encoded string</param>
            <returns>Unencoded string</returns>
        </member>
        <member name="M:Fiddler.Utilities.UrlPathEncode(System.String)">
            <summary>
            Replaces System.Web.HttpUtility.UrlPathEncode(str).
            </summary>
            <param name="str">String to encode as a URL Path</param>
            <returns>Encoded string</returns>
        </member>
        <member name="M:Fiddler.Utilities.Parameterize(System.String,System.Boolean)">
            <summary>
            Tokenize a string into tokens. Delimits on unquoted whitespace ; quote marks are dropped unless preceded by \ characters.
            Some special hackery to allow trailing slash not escape the final character of the entire input, so that:
                  prefs set fiddler.config.path.vsplugins "F:\users\ericlaw\VSWebTest\"
            ...doesn't end up with a trailing quote.
            </summary>
            <param name="sInput">The string to tokenize</param>
            <param name="bAllowSQuote">Are single-quotes allowed to as escapes?</param>
            <returns>An array of strings</returns>
        </member>
        <member name="M:Fiddler.Utilities.ByteArrayToHexView(System.Byte[],System.Int32)">
            <summary>
            Pretty-print a Hex view of a byte array. Slow.
            </summary>
            <param name="inArr">The byte array</param>
            <param name="iBytesPerLine">Number of bytes per line</param>
            <returns>String containing a pretty-printed array</returns>
        </member>
        <member name="M:Fiddler.Utilities.ByteArrayToHexView(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Pretty-print a Hex view of a byte array. Slow.
            </summary>
            <param name="inArr">The byte array</param>
            <param name="iBytesPerLine">Number of bytes per line</param>
            <param name="iMaxByteCount">The maximum number of bytes to pretty-print</param>
            <returns>String containing a pretty-printed array</returns>
        </member>
        <member name="M:Fiddler.Utilities.ByteArrayToHexView(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Pretty-print a Hex view of a byte array. Slow.
            </summary>
            <param name="inArr">The byte array</param>
            <param name="iBytesPerLine">Number of bytes per line</param>
            <param name="iMaxByteCount">The maximum number of bytes to pretty-print</param>
            <param name="bShowASCII">Show ASCII text at the end of each line</param>
            <returns>String containing a pretty-printed array</returns>
        </member>
        <member name="M:Fiddler.Utilities.ByteArrayToString(System.Byte[])">
            <summary>
            Print an byte array to a hex string.
            Slow.
            </summary>
            <param name="inArr">Byte array</param>
            <returns>String of hex bytes, or "null"/"empty" if no bytes provided</returns>
        </member>
        <member name="M:Fiddler.Utilities.StringToCF_HTML(System.String)">
            <summary>
            Create a string in CF_HTML format
            </summary>
            <param name="inStr">The HTML string</param>
            <returns>The HTML string wrapped with a CF_HTML prelude</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetRegistryInt(Microsoft.Win32.RegistryKey,System.String,System.Int32)">
            <summary>
            Returns an integer from the registry, or a default.
            </summary>
            <param name="oReg">The Registry key in which to find the value.</param>
            <param name="sName">The registry value name.</param>
            <param name="iDefault">Default to return if the registry key is missing or cannot be used as an integer</param>
            <returns>The retrieved integer, or the default.</returns>
        </member>
        <member name="M:Fiddler.Utilities.SetRegistryString(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Save a string to the registry. Correctly handles null Value, saving as String.Empty
            </summary>
            <param name="oReg">The registry key into which the value will be written.</param>
            <param name="sName">The name of the value.</param>
            <param name="sValue">The value to write.</param>
        </member>
        <member name="M:Fiddler.Utilities.GetRegistryFloat(Microsoft.Win32.RegistryKey,System.String,System.Single)">
            <summary>
            Returns an Float from the registry, or a default.
            </summary>
            <param name="oReg">Registry key in which to find the value.</param>
            <param name="sName">The value name.</param>
            <param name="flDefault">The default float value if the registry key is missing or cannot be used as a float.</param>
            <returns>Float representing the value, or the default.</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetRegistryBool(Microsoft.Win32.RegistryKey,System.String,System.Boolean)">
            <summary>
            Get a bool from the registry
            </summary>
            <param name="oReg">The RegistryKey</param>
            <param name="sName">The Value name</param>
            <param name="bDefault">The default value</param>
            <returns>Returns an bool from the registry, or bDefault if the registry key is missing or cannot be used as an bool.</returns>
        </member>
        <member name="M:Fiddler.Utilities.FileExtensionForMIMEType(System.String)">
            <summary>
            Maps a MIMEType to a file extension. Note: May hit the registry, so consider the performance implications. 
            Pass only the TYPE (e.g. use oResponse.MIMEType), to ensure no charset info in the string. 
            </summary>
            <param name="sMIME">The MIME Type</param>
            <returns>A file extension for the type, or .TXT</returns>
        </member>
        <member name="M:Fiddler.Utilities.ContentTypeForFilename(System.String)">
            <summary>
            Return the content type of a target file, or application/octet-stream if unknown.
            </summary>
            <param name="sFilename">A filename, including the extension</param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.ContentTypeForFileExtension(System.String)">
            <summary>
            Use the system registry to find the proper MIME-Type for a given file extension.
            WARNING: Calling Path.GetExtension may throw on bad input. Use <see cref="M:Fiddler.Utilities.ContentTypeForFilename(System.String)"/> to guard against that.
            </summary>
            <param name="sExtension">Dot-prefixed file extension (e.g. ".js")</param>
            <returns>Content-Type, or null if one cannot be determined</returns>
        </member>
        <member name="M:Fiddler.Utilities.IsChunkedBodyComplete(Fiddler.Session,System.IO.MemoryStream,System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Determines if we have a complete chunked response body (RFC2616 Section 3.6.1)
            </summary>
            <param name="m_session">The session object, used for error reporting</param>
            <param name="oData">The response data stream. Note: We do not touch the POSITION property.</param>
            <param name="iStartAtOffset">The start of the HTTP body to scan for chunk size info</param>
            <param name="outStartOfLatestChunk">Returns the start of the final received/partial chunk</param>
            <param name="outEndOfEntity">End of byte data in stream representing this chunked content, or -1 if error</param>
            <returns>True, if we've found the complete last chunk, false otherwise.</returns>
        </member>
        <member name="M:Fiddler.Utilities.doChunk(System.Byte[],System.Int32)">
            <summary>
            Takes a byte array and applies HTTP Chunked Transfer Encoding to it
            </summary>
            <param name="writeData">The byte array to convert</param>
            <param name="iSuggestedChunkCount">The number of chunks to try to create</param>
            <returns>The byte array with Chunked Transfer Encoding applied</returns>
        </member>
        <member name="M:Fiddler.Utilities.doUnchunk(System.Byte[])">
            <summary>
            Removes HTTP chunked encoding from the data in writeData and returns the resulting array.
            </summary>
            <param name="writeData">Some chunked data</param>
            <returns>Unchunked data. Throws InvalidDataException on data format errors.</returns>
        </member>
        <member name="M:Fiddler.Utilities.doUnchunk(System.Byte[],Fiddler.Session,System.Boolean)">
            <summary>
            Removes HTTP chunked encoding from the data in writeData and returns the resulting array.
            </summary>
            <param name="writeData">Array to unchunk</param>
            <param name="oS">Optional Session (for UI error messages)</param>
            <param name="bNoUI">TRUE to suppress error messages, FALSE to show alert boxes</param>
            <returns>Unchunked data. Throws InvalidDataException on data format errors.</returns>
        </member>
        <member name="M:Fiddler.Utilities.arrayContainsNonText(System.Byte[])">
            <summary>
            Returns TRUE if the Array contains nulls. TODO: Extend to check for other chars which are clearly non-Unicode
            </summary>
            <param name="arrIn"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.isUnsupportedEncoding(System.String,System.String)">
            <summary>
            Implements a BlockList for "unknown" encodings that the utilDecode* functions cannot handle
            </summary>
            <param name="sTE">Transfer-Encoding</param>
            <param name="sCE">Content-Encoding</param>
            <returns>TRUE if any encoding is known to be unsupported</returns>
        </member>
        <member name="M:Fiddler.Utilities._DecodeInOrder(System.String,System.Boolean,System.Byte[]@,System.Boolean)">
            <summary>
            Removes one or more encodings in the proper order to reconstruct the unencoded body.
            If removing Transfer-Encoding and Content-Encoding, ALWAYS remove Transfer-Encoding first.
            </summary>
            <param name="sEncodingsInOrder">The list of encodings in the order that they were applied 
            RFC2616: If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied.</param>
            <param name="bAllowChunks">Should unchunking be permitted (TRUE for Transfer-Encoding, FALSE for Content-Encoding)</param>
            <param name="arrBody">The bytes of the body</param>
        </member>
        <member name="M:Fiddler.Utilities._TryContentDecode(System.String,System.String@,System.Byte[]@,System.Boolean)">
            <summary>
            Content-Encodings
            </summary>
            <param name="sEncodingsInOrder"></param>
            <param name="?"></param>
            <param name="arrBody"></param>
            <param name="bNoUI"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.utilDecodeHTTPBody(Fiddler.HTTPHeaders,System.Byte[]@)">
            <summary>
            Remove all encodings from arrBody, based on those specified in the supplied HTTP headers; DOES NOT MODIFY HEADERS.
            Throws on errors.
            </summary>
            <param name="oHeaders">*Readonly* headers specifying what encodings are applied</param>
            <param name="arrBody">In/Out array to be modified</param>
        </member>
        <member name="M:Fiddler.Utilities.utilDecodeHTTPBody(Fiddler.HTTPHeaders,System.Byte[]@,System.Boolean)">
            <summary>
            Remove all encodings from arrBody, based on those specified in the supplied HTTP headers; 
            DOES NOT MODIFY HEADERS. DOES NOT HANDLE UNSUPPORTED ENCODINGS WELL.
            Throws on errors.
            </summary>
            <param name="oHeaders">*Readonly* headers specifying what encodings are applied</param>
            <param name="arrBody">In/Out array to be modified</param>
            <param name="bSilent">FALSE to show dialog boxes on errors, TRUE to remain silent</param>
        </member>
        <member name="M:Fiddler.Utilities.utilTryDecode(Fiddler.HTTPHeaders,System.Byte[]@,System.Boolean)">
            <summary>
            Attempts to remove all Content-Encodings from a HTTP body. May throw if content is malformed.
            MODIFIES HEADERS.
            </summary>
            <param name="oHeaders">Headers for the body; Content-Encoding and Content-Length will be modified</param>
            <param name="arrBody">Reference to the body array</param>
            <param name="bSilent">FALSE if error dialog boxes should be shown</param>
            <returns>TRUE if the body was decoded completely.</returns>
        </member>
        <member name="M:Fiddler.Utilities.ZLibExpand(System.Byte[])">
            <summary>
            Decompress an array compressed using an Zlib DEFLATE stream. Not a HTTP Encoding; it's used internally in the PNG format.
            </summary>
            <param name="compressedData">The array to expand</param>
            <returns>byte[] of decompressed data</returns>
        </member>
        <member name="M:Fiddler.Utilities.GzipCompress(System.Byte[])">
            <summary>
            GZIPs a byte-array
            </summary>
            <param name="writeData">Input byte array</param>
            <returns>byte[] containing a gzip-compressed copy of writeData[]</returns>
        </member>
        <member name="M:Fiddler.Utilities.XpressExpandInternal(System.Byte[])">
            <summary>
            Requires Win8+
            Decompress Xpress|Raw blocks used by WSUS, etc.
            Introduction to the API is at http://msdn.microsoft.com/en-us/library/windows/desktop/hh920921(v=vs.85).aspx
            </summary>
            <param name="compressedData"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.GzipExpandInternal(System.Boolean,System.Byte[])">
            <summary>
            GZIP-Expand function which shows no UI and will throw on error
            </summary>
            <param name="bUseXceed">TRUE if you want to use Xceed to decompress; false if you want to use System.IO</param>
            <param name="compressedData">byte[] to decompress</param>
            <returns>A decompressed byte array, or byte[0]. Throws on errors.</returns>
        </member>
        <member name="M:Fiddler.Utilities.GzipExpand(System.Byte[])">
            <summary>
            Expands a GZIP-compressed byte array
            </summary>
            <param name="compressedData">The array to decompress</param>
            <returns>byte[] containing an un-gzipped copy of compressedData[]</returns>
        </member>
        <member name="M:Fiddler.Utilities.DeflaterCompress(System.Byte[])">
            <summary>
            Compress a byte array using RFC1951 DEFLATE
            </summary>
            <param name="writeData">Array to compress</param>
            <returns>byte[] containing a DEFLATE'd copy of writeData[]</returns>
        </member>
        <member name="M:Fiddler.Utilities.DeflaterExpandInternal(System.Boolean,System.Byte[])">
            <summary>
            UnDeflate function which shows no UI and will throw on error
            </summary>
            <param name="bUseXceed">TRUE if you want to use Xceed to decompress; false if you want to use System.IO</param>
            <param name="compressedData">byte[] to decompress</param>
            <returns>A decompressed byte array, or byte[0]. Throws on errors.</returns>
        </member>
        <member name="M:Fiddler.Utilities.XpressExpand(System.Byte[])">
            <summary>
            Decompress a byte array that was compressed using Microsoft's Xpress Raw format.
            Available only on Windows 8+
            </summary>
            <param name="arrBlock">Array to decompress</param>
            <returns>byte[] of decompressed data</returns>
        </member>
        <member name="M:Fiddler.Utilities.DeflaterExpand(System.Byte[])">
            <summary>
            Decompress a byte array that was compressed using RFC1951 DEFLATE 
            </summary>
            <param name="compressedData">Array to decompress</param>
            <returns>byte[] of decompressed data</returns>
        </member>
        <member name="M:Fiddler.Utilities.bzip2Compress(System.Byte[])">
            <summary>
            Compress a byte[] using the bzip2 algorithm
            </summary>
            <param name="writeData">Array to compress</param>
            <returns>byte[] of data compressed using bzip2</returns>
        </member>
        <member name="M:Fiddler.Utilities.bzip2Expand(System.Byte[])">
            <summary>
            Decompress an array compressed using bzip2
            </summary>
            <param name="compressedData">The array to expand</param>
            <returns>byte[] of decompressed data</returns>
        </member>
        <member name="M:Fiddler.Utilities.bzip2Expand(System.Byte[],System.Boolean)">
            <summary>
            Decompress an array compressed using bzip2
            </summary>
            <param name="compressedData">The array to expand</param>
            <returns>byte[] of decompressed data</returns>
        </member>
        <member name="M:Fiddler.Utilities.TryHexParse(System.String,System.Int32@)">
            <summary>
            Try parsing the string for a Hex-formatted int. If it fails, return false and 0 in iOutput.
            </summary>
            <param name="sInput">The hex number</param>
            <param name="iOutput">The int value</param>
            <returns>TRUE if the parsing succeeded</returns>
        </member>
        <member name="M:Fiddler.Utilities.areOriginsEquivalent(System.String,System.String,System.Int32)">
            <summary>
            Returns TRUE if two ORIGIN (scheme+host+port) values are functionally equivalent.
            </summary>
            <param name="sOrigin1">The first ORIGIN</param>
            <param name="sOrigin2">The second ORIGIN</param>
            <param name="iDefaultPort">The default port, if a port is not specified</param>
            <returns>TRUE if the two origins are equivalent</returns>
        </member>
        <member name="M:Fiddler.Utilities.isPlainHostName(System.String)">
            <summary>
            This function cracks a sHostPort string to determine if the address
            refers to a "local" site
            </summary>
            <param name="sHostAndPort">The string to evaluate, potentially containing a port</param>
            <returns>True if the address is local</returns>
        </member>
        <member name="M:Fiddler.Utilities.isLocalhost(System.String)">
            <summary>
            This function cracks a sHostPort string to determine if the address
            refers to the local computer
            </summary>
            <param name="sHostAndPort">The string to evaluate, potentially containing a port</param>
            <returns>True if the address is 127.0.0.1, 'localhost', or ::1</returns>
        </member>
        <member name="M:Fiddler.Utilities.isLocalhostname(System.String)">
            <summary>
            Determines if the specified Hostname is a either 'localhost' or an IPv4 or IPv6 loopback literal
            </summary>
            <param name="sHostname">Hostname (no port)</param>
            <returns>TRUE if the hostname is equivalent to localhost</returns>
        </member>
        <member name="M:Fiddler.Utilities.CrackHostAndPort(System.String,System.String@,System.Int32@)">
            <summary>
            This function cracks the Hostname/Port combo, removing IPV6 brackets if needed
            </summary>
            <param name="sHostPort">Hostname/port combo, like www.foo.com or www.example.com:8888 or [::1]:80</param>
            <param name="sHostname">The hostname, minus any IPv6 literal brackets, if present</param>
            <param name="iPort">Port #, 80 if not specified, -1 if corrupt</param>
        </member>
        <member name="M:Fiddler.Utilities.IPEndPointFromHostPortString(System.String)">
            <summary>
            Given a string/list in the form HOSTNAME:PORT#;HOSTNAME2:PORT2#, this function returns the FIRST IPEndPoint. Defaults to port 80 if not specified.
            Warning: DNS resolution is slow, so use this function wisely.
            </summary>
            <param name="sHostAndPort">HOSTNAME:PORT#;OPTHOST2:PORT2#</param>
            <returns>An IPEndPoint or null</returns>
        </member>
        <member name="M:Fiddler.Utilities.IPEndPointListFromHostPortString(System.String)">
            <summary>
            Given a string/list in the form HOSTNAME:PORT#;HOSTNAME2:PORT2#, this function returns all IPEndPoints for ALL listed hosts. Defaults to port 80 if not specified.
            Warning: DNS resolution is slow, so use this function wisely.
            </summary>
            <param name="sAllHostAndPorts">HOSTNAME:PORT#;OPTHOST2:PORT2#</param>
            <returns>An array of IPEndPoints or null if no results were obtained</returns>
        </member>
        <member name="M:Fiddler.Utilities.IPFromString(System.String)">
            <summary>
            This function attempts to be a ~fast~ way to return an IP from a hoststring that contains an IPv4/6-Literal.
            </summary>
            <param name="sHost">Hostname</param>
            <returns>IPAddress, or null, if the sHost wasn't an IP-Literal</returns>
        </member>
        <member name="M:Fiddler.Utilities.LaunchHyperlink(System.String)">
            <summary>
            Launch the user's browser to a hyperlink. This function traps exceptions and notifies the user via UI dialog.
            </summary>
            <param name="sURL">The URL to ShellExecute.</param>
            <returns>TRUE if the ShellExecute call succeeded.</returns>
        </member>
        <member name="M:Fiddler.Utilities.RunExecutable(System.String,System.String)">
            <summary>
            Wrapper for Process.Start that shows error messages in the event of failure.
            </summary>
            <param name="sExecute">Fully-qualified filename to execute.</param>
            <param name="sParams">Command line parameters to pass.</param>
            <returns>TRUE if the execution succeeded. FALSE if the execution failed. An error message will be shown for any error except the user declining UAC.</returns>
        </member>
        <member name="M:Fiddler.Utilities.RunExecutableAndWait(System.String,System.String)">
            <summary>
            Run an executable and wait for it to exit, notifying the user of any exceptions.
            </summary>
            <param name="sExecute">Fully-qualified filename of file to execute.</param>
            <param name="sParams">Command-line parameters to pass.</param>
            <returns>TRUE if the execution succeeded. FALSE if the error message was shown.</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetExecutableOutput(System.String,System.String,System.Int32@)">
            <summary>
            Run an executable, wait for it to exit, and return its output as a string.
            NOTE: Uses CreateProcess, so you cannot launch applications which require Elevation.
            </summary>
            <param name="sExecute">Fully-qualified filename of file to Execute</param>
            <param name="sParams">Command-line parameters to pass</param>
            <param name="iExitCode">Exit code returned by the executable</param>
            <returns>String containing the standard-output of the executable</returns>
        </member>
        <member name="M:Fiddler.Utilities.CopyToClipboard(System.String)">
            <summary>
            Copy a string to the clipboard, notifying the user of any exceptions
            </summary>
            <param name="sText">The text to copy</param>
            <returns>TRUE if the copy succeeded</returns>
        </member>
        <member name="M:Fiddler.Utilities.CopyToClipboard(System.Windows.Forms.DataObject)">
            <summary>
            Copy an object to the clipboard, notifying the user of any exceptions
            </summary>
            <param name="oData">The object to copy</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Fiddler.Utilities.RegExEscape(System.String,System.Boolean,System.Boolean)">
            <summary>
            This method prepares a string to be converted into a regular expression by escaping special characters and CONVERTING WILDCARDS.
            This method was originally meant for parsing WPAD proxy script strings. 
            
            You typically should use the Static RegEx.Escape method for most purposes, as it doesn't convert "*" into ".*"
            </summary>
            <param name="sString"></param>
            <param name="bAddPrefixCaret"></param>
            <param name="bAddSuffixDollarSign"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.HasMagicBytes(System.Byte[],System.Byte[])">
            <summary>
            Determines whether the arrData array STARTS WITH with the supplied arrMagics bytes. Used for Content-Type sniffing.
            </summary>
            <param name="arrData">The data, or null</param>
            <param name="arrMagics">The MagicBytes to look for</param>
            <returns>TRUE if arrData begins with arrMagics</returns>
        </member>
        <member name="M:Fiddler.Utilities.HasMagicBytes(System.Byte[],System.String)">
            <summary>
            Determines whether the arrData array begins with the supplied sMagics ASCII text. Used for Content-Type sniffing.
            </summary>
            <param name="arrData">The data, or null</param>
            <param name="sMagics">The ASCII text to look for</param>
            <returns>TRUE if arrData begins with sMagics (encoded as ASCII octets)</returns>
        </member>
        <member name="M:Fiddler.Utilities.isRPCOverHTTPSMethod(System.String)">
            <summary>
            Is this HTTPMethod used for RPC-over-HTTPS?
            </summary>
        </member>
        <member name="M:Fiddler.Utilities.isHTTP200Array(System.Byte[])">
            <summary>
            Determine if a given byte array has the start of a HTTP/1.* 200 response.
            Useful primarily to determine if a CONNECT request to a proxy returned success.
            </summary>
            <param name="arrData"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.isHTTP407Array(System.Byte[])">
            <summary>
            Determine if a given byte array has the start of a HTTP/1.* 407 response.
            Useful primarily to determine if a CONNECT request to a proxy returned an auth challenge
            </summary>
            <param name="arrData"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.IsBrowserProcessName(System.String)">
            <summary>
            For a given process name, returns a bool indicating whether this is a known browser process name.
            </summary>
            <param name="sProcessName">The Process name (e.g. "abrowser.exe")</param>
            <returns>Returns true if the process name starts with a common browser process name (e.g. ie, firefox, etc)</returns>
        </member>
        <member name="M:Fiddler.Utilities.EnsurePathIsAbsolute(System.String,System.String)">
            <summary>
            Ensure that a given path is absolute, if not, applying the root path.
            WARNING: This function only works as well as Path.IsPathRooted, which returns "True" for things like "/NoDriveSpecified/fuzzle.txt"
            A better approach would be to look at the internal Path.IsRelative method
            </summary>
            <param name="sRootPath"></param>
            <param name="sFilename"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.GetFirstLocalResponse(System.String)">
            <summary>
            If sFilename is absolute, returns it, otherwise, combines the leaf filename with local response folders hunting for a match.
            Trims at the first ? character, if any
            </summary>
            <param name="sFilename">Either a fully-qualified path, or a leaf filename</param>
            <returns>File path</returns>
        </member>
        <member name="M:Fiddler.Utilities.DescribeException(System.Exception)">
            <summary>
            Format an Exception message, including InnerException message if present.
            </summary>
            <param name="eX"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.GetTickCount">
            <summary>
            Get a TickCount (milliseconds since system start) as an unsigned 64bit value. On Vista+, uses the GetTickCount64 API that won't rollover,
            but on XP, this unsigned wrapper moves the rollover point to 49 days of uptime.
            </summary>
            <returns>Number of ms since Windows started</returns>
        </member>
        <member name="M:Fiddler.Utilities.IsUserAnAdmin">
            <summary>
            Returns TRUE if the user is running Elevated. Requires WinXP to Win8
            </summary>
            <returns>TRUE if the user is an Admin and the process is Elevated</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetOSVerString">
            <summary>
            Returns a succinct version of Environment.OSVersion.VersionString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.IsWin8OrLater">
            <summary>
            Returns TRUE on *Windows* (not Mono) when OS Version is Win8+ (NT6.2+)
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Fiddler.Utilities.ParseSSLProtocolString(System.String)" -->
        <member name="M:Fiddler.Utilities.Dupe(System.Byte[])">
            <summary>
            Duplicate a byte array, replacing null with byte[0].
            Doing this instead of .Clone() because it better handles nulls and it may be faster.
            </summary>
            <param name="bIn">The array to copy</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetMD5Hash(System.Byte[])">
            <summary>
            Warning: This will throw if FIPS mode is enabled
            </summary>
            <param name="bIn"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.IsNullOrEmpty(System.Byte[])">
            <summary>
            Returns TRUE if the array is null or contains 0 bytes
            </summary>
            <param name="bIn">byte[] to test</param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.IsCommentUserSupplied(System.String)">
            <summary>
            Returns TRUE if the string is non-empty and not of the pattern "[#123]"
            Necessary because SAZ-saving logic autogenerates comments of that form
            </summary>
            <param name="strComment"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.HasHeaders(Fiddler.ServerChatter)">
            <summary>
            
            </summary>
            <param name="oSC"></param>
            <returns>True if ClientChatter is non-null and its headers are non-null</returns>
        </member>
        <member name="M:Fiddler.Utilities.HasHeaders(Fiddler.ClientChatter)">
            <summary>
            True if ClientChatter is non-null and its headers are non-null
            </summary>
            <param name="oCC"></param>
            <returns>True if ClientChatter is non-null and its headers are non-null</returns>
        </member>
        <member name="M:Fiddler.Utilities.GetNetworkInfo">
            <summary>
            Return a multi-line string describing the NetworkInterfaces[]
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.Utilities.IsNotExtension(System.String)">
            <summary>
            Checks a DLL's filename for signals that it doesn't contain extensions.
            This hack is only needed because I wasn't smart enough to require that the assembly be named something like Fiddler.* in the original design. 
            </summary>
            <param name="sFilename">DLL filename</param>
            <returns>TRUE if we should skip this assembly during enumeration</returns>
        </member>
        <member name="M:Fiddler.Utilities.RecoverMemory">
            <summary>
            Garbage collect and, if possible, compact the Large Object heap
            </summary>
        </member>
        <member name="T:Fiddler.StringExtensions">
            <summary>
            Common functions we'll want to use on Strings. Fiddler makes extensive use of strings which 
            should be interpreted in a case-insensitive manner.
            
            WARNING: Methods assume that the calling object is not null, which is lame for reliability but arguably good for performance.
            </summary>
        </member>
        <member name="T:Fiddler.WebSocket">
            <summary>
            The WebSocket class represents a "tunnel" through which WebSocket messages flow.
            The class' messages may be deserialized from a SAZ file.
            </summary>
        </member>
        <member name="F:Fiddler.WebSocket.bParseMessages">
            <summary>
            Should this WebSocket Tunnel parse the WS traffic within into individual messages?
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket.WriteWebSocketMessageListToStream(System.IO.Stream)">
            <summary>
            Writes all of the messages stored in this WebSocket to a stream.
            </summary>
            <param name="oFS"></param>
            <returns></returns>
        </member>
        <member name="M:Fiddler.WebSocket.MemoryUsage">
            <summary>
            Approximate size of the data of the stored messages, used for memory tracking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.WebSocket._ReadHeadersFromStream(System.IO.Stream)">
            <summary>
            Read headers from the stream.
            </summary>
            <param name="oFS">The Stream from which WebSocketSerializationHeaders should be read</param>
            <returns>The Array of headers, or String[0]</returns>
        </member>
        <member name="F:Fiddler.WebSocket._lngEgressByteCount">
            <summary>
            Number of bytes received from the client
            </summary>
        </member>
        <member name="F:Fiddler.WebSocket._lngIngressByteCount">
            <summary>
            Number of bytes received from the server
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket.LoadWebSocketMessagesFromStream(Fiddler.Session,System.IO.Stream)">
            <summary>
            Creates a "detached" WebSocket which contains messages loaded from the specified stream
            </summary>
            <param name="oS">Session to which the WebSocket messages belong</param>
            <param name="strmWSMessages">The Stream containing messages, which will be closed upon completion</param>
        </member>
        <member name="M:Fiddler.WebSocket.CreateTunnel(Fiddler.Session)">
            <summary>
            This factory method creates a new WebSocket Tunnel and executes it on a background (non-pooled) thread.
            </summary>
            <param name="oSession">The Session containing the HTTP CONNECT request</param>
        </member>
        <member name="M:Fiddler.WebSocket.#ctor(Fiddler.Session,Fiddler.ClientPipe,Fiddler.ServerPipe)">
            <summary>
            Creates a WebSocket tunnel. External callers instead use the CreateTunnel static method.
            </summary>
            <param name="oSess">The session for which this tunnel was initially created.</param>
            <param name="oFrom">The client pipe</param>
            <param name="oTo">The server pipe</param>
        </member>
        <member name="M:Fiddler.WebSocket.WaitForCompletion">
            <summary>
            This function keeps the Tunnel/Thread alive until it is signaled that the traffic is complete
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket._CleanupWebSocket">
            <summary>
            Performs cleanup of the WebSocket instance. Call this after the WebSocket closes normally or after abort/exceptions.
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket.RunTunnel">
            <summary>
            Executes the WebSocket tunnel on a background thread
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket.CloseTunnel">
            <summary>
            Interface Method
            Close the WebSocket and signal the event to let its service thread die. Also called by oSession.Abort()
            WARNING: This should not be allowed to throw any exceptions, because it will do so on threads that don't 
            catch them, and this will kill the application.
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket._PushClientBuffer(System.Int32)">
            <summary>
            When we get a buffer from the client, we push it into the memory stream
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket._PushServerBuffer(System.Int32)">
            <summary>
            When we get a buffer from the server, we push it into the memory stream
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket._ParseAndSendClientMessages">
            <summary>
            This method parses the data in strmClientBytes to extact one or more WebSocket messages. It then sends each message
            through the pipeline.
            </summary>
        </member>
        <member name="M:Fiddler.WebSocket._ParseAndSendServerMessages">
            This method parses the data in strmServerBytes to extact one or more WebSocket messages. It then sends each message
            through the pipeline to the client.
        </member>
        <member name="M:Fiddler.WebSocket.OnReceiveFromClient(System.IAsyncResult)">
            <summary>
             Called when we have received data from the local client.
            </summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="M:Fiddler.WebSocket.OnReceiveFromServer(System.IAsyncResult)">
            <summary>Called when we have received data from the remote host. Incoming data will immediately be forwarded to the local client.</summary>
            <param name="ar">The result of the asynchronous operation.</param>
        </member>
        <member name="P:Fiddler.WebSocket.IsOpen">
            <summary>
            Is this WebSocket open/connected?
            </summary>
        </member>
        <member name="P:Fiddler.WebSocket.IsBlind">
            <summary>
            Boolean that determines whether the WebSocket tunnel tracks messages.
            </summary>
        </member>
        <member name="P:Fiddler.WebSocket.IngressByteCount">
            <summary>
            Returns number of bytes sent from the Server to the Client on this WebSocket
            </summary>
        </member>
        <member name="P:Fiddler.WebSocket.EgressByteCount">
            <summary>
            Returns number of bytes sent from the Client to the Server on this WebSocket
            </summary>
        </member>
        <member name="T:Fiddler.WSMFlags">
            <summary>
            This enumeration provides the values for the WebSocketMessage object's BitFlags field
            </summary>
        </member>
        <member name="F:Fiddler.WSMFlags.None">
            <summary>
            No flags are set
            </summary>
        </member>
        <member name="F:Fiddler.WSMFlags.Aborted">
            <summary>
            Message was eaten ("dropped") by Fiddler
            </summary>
        </member>
        <member name="F:Fiddler.WSMFlags.GeneratedByFiddler">
            <summary>
            Message was generated ("injected") by Fiddler itself
            </summary>
        </member>
        <member name="F:Fiddler.WSMFlags.Assembled">
            <summary>
            Fragmented Message was reassembled by Fiddler
            </summary>
        </member>
        <member name="F:Fiddler.WSMFlags.Breakpointed">
            <summary>
            Breakpointed
            </summary>
        </member>
        <member name="T:Fiddler.WebSocketMessage">
            <summary>
            A WebSocketMessage stores a single frame of a single WebSocket message
            http://tools.ietf.org/html/rfc6455
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketMessage._byteReservedFlags">
            <summary>
            3 bits frame-rsv1,frame-rsv2,frame-rsv3
            </summary>
        </member>
        <member name="M:Fiddler.WebSocketMessage.UnmaskData(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Unmasks the first array into the third, using the second as a masking key.
            </summary>
            <param name="arrIn"></param>
            <param name="arrKey"></param>
            <param name="arrOut"></param>
        </member>
        <member name="M:Fiddler.WebSocketMessage.MaskDataInPlace(System.Byte[],System.Byte[])">
            <summary>
            Masks the first array's data using the key in the second
            </summary>
            <param name="arrInOut">The data to be masked</param>
            <param name="arrKey">A 4-byte obfuscation key, or null.</param>
        </member>
        <member name="M:Fiddler.WebSocketMessage.SetPayload(System.String)">
            <summary>
            Replaces the WebSocketMessage's payload with the specified string, masking if needed.
            </summary>
            <param name="sPayload"></param>
        </member>
        <member name="M:Fiddler.WebSocketMessage.SetPayload(System.Byte[])">
            <summary>
            Copies the provided byte array over the WebSocketMessage's payload, masking if needed.
            </summary>
            <param name="arrNewPayload"></param>
        </member>
        <member name="M:Fiddler.WebSocketMessage._SetPayloadWithoutCopy(System.Byte[])">
            <summary>
            Masks the provided array (if necessary) and assigns it to the WebSocketMessage's payload.
            </summary>
            <param name="arrNewPayload">New array of data</param>
        </member>
        <member name="M:Fiddler.WebSocketMessage.PayloadAsString">
            <summary>
            Return the WebSocketMessage's payload as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.WebSocketMessage.PayloadAsBytes">
            <summary>
            Copy the WebSocketMessage's payload into a new Byte Array.
            </summary>
            <returns>A new byte array containing the (unmasked) payload.</returns>
        </member>
        <member name="F:Fiddler.WebSocketMessage._bOutbound">
            <summary>
            Is this a Request message?
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketMessage.Timers">
            <summary>
            The WebSocketTimers collection tracks the timestamps for this message
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketMessage._arrRawPayload">
            <summary>
            The raw payload data, which may be masked.
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketMessage._arrMask">
            <summary>
            The four-byte payload masking key, if any
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketMessage._wsftType">
            <summary>
            The type of the WebSocket Message's frame
            </summary>
        </member>
        <member name="M:Fiddler.WebSocketMessage.SerializeToStream(System.IO.Stream)">
            <summary>
            Serialize this message to a stream
            </summary>
            <param name="oFS"></param>
        </member>
        <member name="M:Fiddler.WebSocketMessage.Assemble(Fiddler.WebSocketMessage)">
            <summary>
            Add the content of the subequent continuation to me.
            </summary>
            <param name="oWSM"></param>
        </member>
        <member name="T:Fiddler.WebSocketTimers">
            <summary>
            Timers
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketTimers.dtDoneRead">
            <summary>
            When was this message read from the sender
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketTimers.dtBeginSend">
            <summary>
            When did transmission of this message to the recipient begin
            </summary>
        </member>
        <member name="F:Fiddler.WebSocketTimers.dtDoneSend">
            <summary>
            When did transmission of this message to the recipient end
            </summary>
        </member>
        <member name="M:Fiddler.WebSocketTimers.ToHeaderString">
            <summary>
            Return the timers formatted to be placed in pseudo-headers used in saving the WebSocketMessage to a stream (SAZ).
            NOTE: TRAILING \r\n is critical.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fiddler.WinHTTPAutoProxy">
            <summary>
            The WinHTTPAutoProxy class is used to handle upstream gateways when the client was configured to use WPAD or an Proxy AutoConfig (PAC) script.
            </summary>
        </member>
        <member name="F:Fiddler.WinHTTPAutoProxy.iAutoProxySuccessCount">
            <summary>
            Indication as to whether AutoProxy information is valid. 0=Unknown/Enabled; 1=Valid/Enabled; -1=Invalid/Disabled
            </summary>
        </member>
        <member name="M:Fiddler.WinHTTPAutoProxy.GetPACFileText(System.String)">
            <summary>
            Get the text of the file located at a specified file URI, or null if the URI is non-file or the file is not found.
            </summary>
        </member>
        <member name="M:Fiddler.WinHTTPAutoProxy.ToString">
            <summary>
            Returns a string containing the currently selected autoproxy options
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fiddler.WinHTTPAutoProxy.GetWPADUrl">
            <summary>
            Get WPAD-discovered URL for display purposes (e.g. Help> About); note that we don't actually use this when determining the gateway,
            instead relying on the WinHTTPGetProxyForUrl function to do this work for us.
            </summary>
            <returns>A WPAD url, if found, or String.Empty</returns>
        </member>
        <member name="M:Fiddler.WinHTTPAutoProxy.GetAutoProxyForUrl(System.String,System.Net.IPEndPoint@)">
            <summary>
            Return gateway endpoint for requested Url. TODO: Add caching layer on our side? TODO: Support multiple results?
            </summary>
            <param name="sUrl">The URL for which the gateway should be determined</param>
            <param name="ipepResult">The Endpoint of the Gateway, or null</param>
            <returns>TRUE if WinHttpGetProxyForUrl succeeded</returns>
        </member>
        <member name="M:Fiddler.WinHTTPAutoProxy.Dispose">
            <summary>
            Close the WinHTTP Session handle
            </summary>
        </member>
        <member name="M:Fiddler.WinHTTPNative.WinHttpGetProxyForUrl(System.IntPtr,System.String,Fiddler.WinHTTPNative.WINHTTP_AUTOPROXY_OPTIONS@,Fiddler.WinHTTPNative.WINHTTP_PROXY_INFO@)">
            <summary>
            Note: Be sure to use the same hSession to prevent redownload of the proxy script
            </summary>
        </member>
        <member name="F:Fiddler.WinHTTPNative.WINHTTP_AUTOPROXY_OPTIONS.fAutoLoginIfChallenged">
            <summary>
            Set to true to send Negotiate creds when challenged to download the script
            </summary>
        </member>
        <member name="T:Fiddler.WinINETCache">
            <summary>
            Wrapper for WinINET cache APIs. 
            </summary>
        </member>
        <member name="M:Fiddler.WinINETCache.ClearCookies">
            <summary>
            Clear all HTTP Cookies from the WinINET Cache
            </summary>
        </member>
        <member name="M:Fiddler.WinINETCache.ClearFiles">
            <summary>
            Clear all files from the WinINET Cache
            </summary>
        </member>
        <member name="M:Fiddler.WinINETCache.ClearCookiesForHost(System.String)">
            <summary>
            Delete all permanent WinINET cookies for sHost; won't clear memory-only session cookies. Supports hostnames with an optional leading wildcard, e.g. *example.com. NOTE: Will not work on VistaIE Protected Mode cookies.
            </summary>
            <param name="sHost">The hostname whose cookies should be cleared</param>
        </member>
        <member name="M:Fiddler.WinINETCache.ClearCacheItems(System.Boolean,System.Boolean)">
            <summary>
            Clear the Cache items.  Note: May be synchronous, may be asynchronous.
            </summary>
            <param name="bClearFiles">TRUE if cache files should be cleared</param>
            <param name="bClearCookies">TRUE if cookies should be cleared</param>
        </member>
        <member name="T:Fiddler.WinINETCache.INTERNET_CACHE_ENTRY_INFOA">
            <summary>
            For PInvoke: Contains information about an entry in the Internet cache
            </summary>
        </member>
        <member name="T:Fiddler.WinINETProxyInfo">
            <summary>
            Wrapper for WinINET proxy configuration APIs
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._sHostsThatBypass">
            <summary>
            Hostnames of sites to bypass proxy. &lt;local&gt; is common.
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._bDirect">
            <summary>
            Allow direct connection to host
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._bAutoDetect">
            <summary>
            Attempt WPAD autoproxy detection
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._bAutoDetectWasUserSet">
            <summary>
            Ignore WinINET "no autoproxy unticks box" optimization
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._bUseConfigScript">
            <summary>
            Use user-supplied URL to get FindProxyForURL script
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._bProxiesSpecified">
            <summary>
            Use user-supplied manual/fixed proxy address list
            </summary>
        </member>
        <member name="F:Fiddler.WinINETProxyInfo._sScriptURL">
            <summary>
            WPAD script url that may be used if _bUseScript true
            </summary>
        </member>
        <member name="M:Fiddler.WinINETProxyInfo.CreateFromNamedConnection(System.String)">
            <summary>
            Gathers proxy information from a named connection.
            </summary>
            <param name="sConnectionName">Pass DefaultLAN to look for the "null" connection</param>
            <returns>Proxy info, or null</returns>
        </member>
        <member name="M:Fiddler.WinINETProxyInfo.ToString">
            <summary>
            Get a string describing the proxy settings
            </summary>
            <returns>Returns a multi-line string representing the proxy settings</returns>
        </member>
        <member name="M:Fiddler.WinINETProxyInfo.CalculateProxyString">
            <summary>
            Calculate a string suitable for passing into WinINET APIs.
            </summary>
            <returns>Returns a string containing proxy information, or NULL. NB: I've seen WinINET blow up when passed String.Empty rather than null.
            </returns>
        </member>
        <member name="M:Fiddler.WinINETProxyInfo.SetManualProxies(System.String)">
            <summary>
            Given a proxy string, we crack out the proxy gateways for each protocol
            </summary>
            <param name="sProxyString">e.g. HTTP=itgproxy:80;FTP=ftpprox:21;</param>
            <returns>false on error</returns>
        </member>
        <member name="M:Fiddler.WinINETProxyInfo.GetFromWinINET(System.String)">
            <summary>
            Fills this WinINETProxyInfo instance with settings from specified WinINET connection.
            </summary>
            <param name="sConnectionName">Name of the connection. Pass NULL for LAN connection.</param>
            <returns>TRUE if the settings were successfully retrieved.</returns>
        </member>
        <member name="M:Fiddler.WinINETProxyInfo.SetToWinINET(System.String)">
            <summary>
            Sets WinINET proxy settings for specified connection to those specified in this WinINETProxy instance.
            </summary>
            <param name="sConnectionName">Name of the connection. Pass NULL for LAN connection.</param>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.sHostsThatBypass">
            <summary>
            Semi-colon delimited list of hostnames that should bypass the fixed proxy
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.bUseManualProxies">
            <summary>
            TRUE if manually-specified proxy should be used.
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.bAllowDirect">
            <summary>
            TRUE if a direct HTTP connection may be made if AutoProxy/PAC is unreachable or corrupt
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.bBypassIntranetHosts">
            <summary>
            True if the proxy should be bypassed for dotless hostnames.
            NOTE: Simply looks at the bypassList string to see if it contains a LOCAL rule.
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.sHttpProxy">
            <summary>
            String representing the endpoint of the proxy for HTTP-traffic, if configured
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.sHttpsProxy">
            <summary>
            String representing the endpoint of the proxy for HTTPS-traffic, if configured
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.sFtpProxy">
            <summary>
            String representing the endpoint of the proxy for FTP-traffic, if configured
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.sSocksProxy">
            <summary>
            String representing the endpoint of the proxy for SOCKS-traffic, if configured
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.bAutoDetect">
            <summary>
            Bool indicating whether this connection is set to autodetect the proxy
            </summary>
        </member>
        <member name="P:Fiddler.WinINETProxyInfo.sPACScriptLocation">
            <summary>
            Returns a string pointing to the ProxyAutoConfig script, or null if there is no such URL or it is not enabled
            </summary>
        </member>
        <member name="T:Fiddler.RASInfo">
            <summary>
            The RASInfo class is used to enumerate Network Connectoids so Fiddler can adjust proxy configuration for all connectoids, not just the DefaultLAN
            </summary>
        </member>
        <member name="M:Fiddler.RASInfo.GetConnectionNames">
            <summary>
            Ask RAS for the list of network connectoids. We'll always add "DefaultLAN" to this list as well.
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
